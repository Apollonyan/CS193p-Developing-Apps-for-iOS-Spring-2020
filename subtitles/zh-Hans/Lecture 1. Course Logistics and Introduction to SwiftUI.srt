1
00:00:00,998 --> 00:00:03,498
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:04,920 --> 00:00:06,513
>> [旁白] 斯坦福大学

3
00:00:08,430 --> 00:00:12,470
>> 欢迎收看斯坦福 CS193p 公开课

4
00:00:12,470 --> 00:00:16,730
现在是 2020 年春季学期

5
00:00:16,730 --> 00:00:19,940
我是 Paul Hegarty
我将带领你走进

6
00:00:19,940 --> 00:00:23,230
使用 SwiftUI 在 iOS 平台

7
00:00:23,230 --> 00:00:26,490
开发程序的新探险

8
00:00:26,490 --> 00:00:28,530
这个学期
真是一次新的尝试

9
00:00:28,530 --> 00:00:31,810
因为你们都不像我
还留守在校园里

10
00:00:31,810 --> 00:00:33,310
我其实觉得有些伤心

11
00:00:33,310 --> 00:00:35,570
而且这感觉有些奇怪

12
00:00:35,570 --> 00:00:38,670
我相信你们
也还没有完全适应

13
00:00:38,670 --> 00:00:41,860
但这对于我们这节课

14
00:00:41,860 --> 00:00:43,930
其实影响不大，说真的

15
00:00:43,930 --> 00:00:46,010
因为大部分

16
00:00:46,010 --> 00:00:48,980
我们之间的交流

17
00:00:48,980 --> 00:00:51,930
是通过课程论坛 Piazza 进行

18
00:00:51,930 --> 00:00:53,769
所以你一定要登录 Piazza

19
00:00:53,769 --> 00:00:55,840
然后在那里提问

20
00:00:55,840 --> 00:00:57,273
大胆发言

21
00:00:58,260 --> 00:01:00,540
我们会非常快地回复你

22
00:01:00,540 --> 00:01:03,110
也看看你的同学们在问什么

23
00:01:03,110 --> 00:01:06,090
特别是要注意看我发的帖子

24
00:01:06,090 --> 00:01:08,520
因为所有的课程资料和通知

25
00:01:08,520 --> 00:01:10,650
都是通过 Piazza 发的

26
00:01:10,650 --> 00:01:12,353
所以不要把那些给错过了

27
00:01:13,290 --> 00:01:15,720
因为所有的课程
都是提前录制好的

28
00:01:15,720 --> 00:01:17,070
就像你现在看的这个一样

29
00:01:17,070 --> 00:01:19,590
那这对你来说应该挺方便的

30
00:01:19,590 --> 00:01:20,860
因为我把视频放出来以后

31
00:01:20,860 --> 00:01:22,790
你可以在自己有空的时候看

32
00:01:22,790 --> 00:01:24,800
选择变速、暂停、倒退

33
00:01:24,800 --> 00:01:28,330
特别是，因为我会做很多的演示

34
00:01:28,330 --> 00:01:30,940
那些是特别有价值的

35
00:01:30,940 --> 00:01:33,810
这还有个好处是

36
00:01:33,810 --> 00:01:38,010
就像我们这门课
之前也做过很多次一样

37
00:01:38,010 --> 00:01:42,250
是我们会把它免费公开给全世界

38
00:01:42,250 --> 00:01:44,040
让大家都可以观看

39
00:01:44,040 --> 00:01:46,354
偷窥我们，看我们

40
00:01:46,354 --> 00:01:48,890
在斯坦福上这门课都干了什么

41
00:01:48,890 --> 00:01:50,260
我们今年也会这么做

42
00:01:50,260 --> 00:01:53,140
在加上外挂字幕

43
00:01:53,140 --> 00:01:55,230
和其他后期处理之后就会公开

44
00:01:55,230 --> 00:01:58,250
所以如果你不是斯坦福大学的学生

45
00:01:58,250 --> 00:02:00,430
也欢迎你来听课！

46
00:02:00,430 --> 00:02:03,000
当然，你无法参加我们

47
00:02:03,000 --> 00:02:05,020
其他斯坦福学生的论坛

48
00:02:05,020 --> 00:02:07,593
因为你看这个的时候
我们已经讲完了

49
00:02:08,630 --> 00:02:11,130
但有很多其他社区提供的资源

50
00:02:11,130 --> 00:02:13,140
让你可以在上面提问

51
00:02:13,140 --> 00:02:14,570
比如像著名网站
Stack Overflow

52
00:02:14,570 --> 00:02:18,640
建议你去那些地方寻求帮助

53
00:02:18,640 --> 00:02:21,260
SwiftUI 是一个崭新的开发框架

54
00:02:21,260 --> 00:02:22,730
它的出现就是几个月前的事情

55
00:02:22,730 --> 00:02:26,120
所以你将会使用最前沿的技术

56
00:02:26,120 --> 00:02:29,510
开发 iOS 应用

57
00:02:29,510 --> 00:02:31,730
不过当你学习它的时候

58
00:02:31,730 --> 00:02:33,790
会有种似曾相识感

59
00:02:33,790 --> 00:02:34,623
因为在学习过程中会遇到一些

60
00:02:34,623 --> 00:02:36,720
面向对象编程的思想

61
00:02:36,720 --> 00:02:40,040
而你要学习的语言有一点像 C

62
00:02:40,040 --> 00:02:43,660
还采用了类似 Java 的语法形式

63
00:02:43,660 --> 00:02:45,120
所以你会感到
和你之前学过的知识都非常相似

64
00:02:45,120 --> 00:02:46,910
虽然如此，你依然可能要学习

65
00:02:46,910 --> 00:02:50,470
非常多全新的内容

66
00:02:50,470 --> 00:02:51,970
举个例子

67
00:02:51,970 --> 00:02:53,640
你将会学到一个新的编程语言，Swift

68
00:02:53,640 --> 00:02:57,070
我敢肯定几乎你们所有人
都是头一回听说

69
00:02:57,070 --> 00:02:58,470
这门编程语言

70
00:02:58,470 --> 00:03:00,320
本身是支持面向对象编程的

71
00:03:00,320 --> 00:03:02,520
但它还支持另一种编程的形式

72
00:03:02,520 --> 00:03:04,220
我们称之为函数式编程

73
00:03:04,220 --> 00:03:06,350
或者叫做面向协议编程

74
00:03:06,350 --> 00:03:09,000
我不会假设你们了解函数式编程

75
00:03:09,000 --> 00:03:12,880
所以，在这门课的过程中
我会教授你们相关的内容

76
00:03:12,880 --> 00:03:16,670
用户界面的编写方法
我们称之为响应式编程

77
00:03:16,670 --> 00:03:19,440
是一种声明式的写法
而不是我们平时常见的命令式

78
00:03:19,440 --> 00:03:21,490
这些都是非常新的知识

79
00:03:21,490 --> 00:03:22,950
我会向你们慢慢解释这些概念的含义

80
00:03:22,950 --> 00:03:25,890
当然，在这门课程中还有各色各样新的话题

81
00:03:25,890 --> 00:03:28,920
比如，我们将会使用

82
00:03:28,920 --> 00:03:30,830
iOS 中的面向对象数据库

83
00:03:30,830 --> 00:03:33,180
这可是一个非常酷的技术

84
00:03:33,180 --> 00:03:36,480
无论如何，这门课

85
00:03:36,480 --> 00:03:40,000
有一点实践课程的感觉

86
00:03:40,000 --> 00:03:43,440
我们会在课程中
开发一些真实的 iOS 应用

87
00:03:43,440 --> 00:03:46,450
你还会在这门课中
综合应用到其他计算机的知识

88
00:03:46,450 --> 00:03:49,760
很显然我们会用到人机交互的知识

89
00:03:49,760 --> 00:03:52,310
还有 API 设计以及语言的设计

90
00:03:52,310 --> 00:03:54,640
我们还会学习动画，数据持久化
网络编程，多线程等

91
00:03:54,640 --> 00:03:56,220
所有列出来的这些

92
00:03:56,220 --> 00:03:59,130
都是我们确定

93
00:03:59,130 --> 00:04:00,610
会在这门课程中学习的

94
00:04:00,610 --> 00:04:03,000
所以你将会看到它们一起

95
00:04:03,000 --> 00:04:05,950
出现在真实开发环境中

96
00:04:05,950 --> 00:04:07,550
现在我们来谈谈

97
00:04:07,550 --> 00:04:08,850
这门课的机制

98
00:04:08,850 --> 00:04:11,430
例如它具体是如何进行的

99
00:04:11,430 --> 00:04:14,350
在这些已经录好的课程里

100
00:04:14,350 --> 00:04:16,940
大部分时间我都在做演示

101
00:04:16,940 --> 00:04:18,480
我非常信任示例程序

102
00:04:18,480 --> 00:04:21,090
因为它们能让抽象的概念变得非常具体

103
00:04:21,090 --> 00:04:24,840
所以我会花大概 2/3 的时间做演示

104
00:04:24,840 --> 00:04:28,110
但是偶尔我也会

105
00:04:28,110 --> 00:04:30,190
用幻灯片介绍概念

106
00:04:30,190 --> 00:04:32,530
因为如果你不理解这些概念

107
00:04:32,530 --> 00:04:35,151
那么示例程序就毫无意义了

108
00:04:35,151 --> 00:04:37,420
例如在第二课开头

109
00:04:37,420 --> 00:04:40,740
我会介绍一种叫做 MVVM 的设计范式

110
00:04:40,740 --> 00:04:42,560
我们用它来组织代码

111
00:04:42,560 --> 00:04:45,130
我也会介绍 Swift 中的类型系统

112
00:04:45,130 --> 00:04:46,970
因为它对理解

113
00:04:46,970 --> 00:04:50,830
Swift 的工作原理至关重要

114
00:04:50,830 --> 00:04:53,610
但重申一下，如果可以的话
我更倾向于做演示

115
00:04:53,610 --> 00:04:54,900
因为我们想把时间

116
00:04:54,900 --> 00:04:56,740
花在真正的 iOS 开发上

117
00:04:56,740 --> 00:04:58,930
这才是我们在这里要学的东西

118
00:04:58,930 --> 00:05:01,660
在前三周，你会有一些

119
00:05:01,660 --> 00:05:02,750
阅读任务

120
00:05:02,750 --> 00:05:05,740
绝大部分都是 Swift 这门语言的学习资料

121
00:05:05,740 --> 00:05:09,100
网上有 Swift 编程参考手册

122
00:05:09,100 --> 00:05:12,040
在前三周我会带着你们

123
00:05:12,040 --> 00:05:13,980
快速的通读它

124
00:05:13,980 --> 00:05:15,930
因为这文档太长了

125
00:05:15,930 --> 00:05:17,990
我不想让你

126
00:05:17,990 --> 00:05:20,060
在这里花太长时间

127
00:05:20,060 --> 00:05:22,320
同时也因为只有会了 Swift

128
00:05:22,320 --> 00:05:23,900
你才能写 SwiftUI

129
00:05:24,890 --> 00:05:26,953
当然编程作业也是有的

130
00:05:26,953 --> 00:05:29,363
它们通常会持续一周时间

131
00:05:30,220 --> 00:05:32,550
总共有 4 或 5 个

132
00:05:32,550 --> 00:05:35,770
这个学期延迟了一周开学，所以有点短

133
00:05:35,770 --> 00:05:37,930
因此这 4 或 5 个编程作业

134
00:05:37,930 --> 00:05:40,140
会在前六周布置

135
00:05:40,140 --> 00:05:43,010
剩下的后三周我会留给你

136
00:05:43,010 --> 00:05:45,210
去完成期末项目

137
00:05:45,210 --> 00:05:46,950
期末项目将会是你学过的

138
00:05:46,950 --> 00:05:48,690
所有东西的融合

139
00:05:48,690 --> 00:05:50,870
因此在最后三周

140
00:05:50,870 --> 00:05:53,100
不会有任何编程作业

141
00:05:53,100 --> 00:05:55,880
在课程论坛中

142
00:05:55,880 --> 00:05:59,027
也有很多信息

143
00:05:59,027 --> 00:06:00,750
包括课程大纲

144
00:06:00,750 --> 00:06:01,940
如果你还没有看过

145
00:06:01,940 --> 00:06:02,850
我建议你去看一遍

146
00:06:02,850 --> 00:06:04,260
如果已经看过当然最好

147
00:06:04,260 --> 00:06:07,410
现在我们来开始构建第一个 app

148
00:06:07,410 --> 00:06:09,740
我做了一个视频

149
00:06:09,740 --> 00:06:13,510
来演示这个 app 的功能

150
00:06:13,510 --> 00:06:15,530
app 的界面样式如图

151
00:06:15,530 --> 00:06:16,970
这是一个纸牌配对游戏

152
00:06:16,970 --> 00:06:19,150
看过往期课程的人

153
00:06:19,150 --> 00:06:21,030
应该会觉得似曾相识

154
00:06:21,030 --> 00:06:22,920
但我们这次会全程使用 SwiftUI 构建

155
00:06:22,920 --> 00:06:25,260
所以这会是一个全新的 app

156
00:06:25,260 --> 00:06:27,640
我们也会加入一些全新的功能

157
00:06:27,640 --> 00:06:30,330
SwiftUI 的特性
让这些新的功能易于构建

158
00:06:30,330 --> 00:06:32,150
比如说这里有很多动画效果

159
00:06:32,150 --> 00:06:33,653
这些卡片可以翻转

160
00:06:34,770 --> 00:06:36,150
在卡片配对时

161
00:06:36,150 --> 00:06:38,780
还会有数字飘出

162
00:06:38,780 --> 00:06:41,140
还有彩色的环形进度条

163
00:06:41,140 --> 00:06:43,910
在卡片背景中倒计时

164
00:06:43,910 --> 00:06:45,670
我们会实现许多动画效果

165
00:06:45,670 --> 00:06:48,883
动画效果对于精良的 UI 至关重要

166
00:06:50,610 --> 00:06:54,400
这个 app 也有

167
00:06:54,400 --> 00:06:57,070
多种主题和不同配色

168
00:06:57,070 --> 00:06:59,110
有万圣节主题

169
00:06:59,110 --> 00:07:01,140
也有旗帜主题

170
00:07:01,140 --> 00:07:03,960
这些卡片会显示多种 emoji

171
00:07:03,960 --> 00:07:05,580
当然，这个演示视频

172
00:07:05,580 --> 00:07:07,270
进度非常快

173
00:07:07,270 --> 00:07:08,970
你可以在观看这节课程时

174
00:07:08,970 --> 00:07:10,960
选择变速、暂停、倒退

175
00:07:10,960 --> 00:07:13,550
来仔细观察其中的一些动画效果

176
00:07:13,550 --> 00:07:15,500
和其他细节

177
00:07:16,580 --> 00:07:17,690
我们将会在

178
00:07:17,690 --> 00:07:20,670
前二至三周的课程中
通过课堂演示和

179
00:07:20,670 --> 00:07:24,423
课后作业的形式
构建这个 app

180
00:07:26,610 --> 00:07:28,220
顺带一提
在这个学期里

181
00:07:28,220 --> 00:07:30,010
你多半看不到我本人的画面

182
00:07:30,010 --> 00:07:32,070
因为我们采用了录屏的方式上课

183
00:07:32,070 --> 00:07:35,030
所以你只会听见我的声音

184
00:07:35,030 --> 00:07:36,510
而且我的声音

185
00:07:36,510 --> 00:07:37,680
也会听起来不太一样

186
00:07:37,680 --> 00:07:39,300
因为我打算用 AirPods

187
00:07:39,300 --> 00:07:42,320
来录制收音

188
00:07:42,320 --> 00:07:44,940
它会过滤一些诸如鼠标声

189
00:07:44,940 --> 00:07:47,500
和键盘声之类的杂音

190
00:07:47,500 --> 00:07:51,110
所以如果你在接下来的课程中见不到我

191
00:07:51,110 --> 00:07:54,380
请享受我曼妙的嗓音（邪魅一笑

192
00:07:54,380 --> 00:07:56,130
我们做的所有工作

193
00:07:56,130 --> 00:07:58,620
将会在一个叫做 Xcode 的软件中进行

194
00:07:58,620 --> 00:08:00,740
这是 iOS 的开发环境

195
00:08:00,740 --> 00:08:01,850
包含了开发用到的所有东西

196
00:08:01,850 --> 00:08:04,540
它包含源代码编辑、编译器

197
00:08:04,540 --> 00:08:07,200
调试器，是一体化的开发环境

198
00:08:07,200 --> 00:08:09,100
你可以从 App Store 免费下载它

199
00:08:09,100 --> 00:08:11,070
如果你在 Mac 上进入 App Store

200
00:08:11,070 --> 00:08:12,493
然后搜索 Xcode

201
00:08:13,691 --> 00:08:16,160
你将会发现它应该是第一个结果

202
00:08:16,160 --> 00:08:17,990
你看，这个就是

203
00:08:17,990 --> 00:08:21,240
这就是 Xcode 启动后的样子

204
00:08:21,240 --> 00:08:25,430
你第一次的课后作业的第一步

205
00:08:25,430 --> 00:08:27,550
就是重复前两节课中

206
00:08:27,550 --> 00:08:28,710
我所做的事情

207
00:08:28,710 --> 00:08:33,580
我建议你现在暂停视频
并下载 Xcode

208
00:08:33,580 --> 00:08:35,610
准备好跟进我的操作

209
00:08:35,610 --> 00:08:38,120
你也可以先轻松地看完

210
00:08:38,120 --> 00:08:40,230
观看并学习必要的知识

211
00:08:40,230 --> 00:08:42,910
之后再重新收看

212
00:08:42,910 --> 00:08:46,720
以完成作业

213
00:08:46,720 --> 00:08:51,050
这就是 Xcode 的启动屏幕
它分为两个部分

214
00:08:51,050 --> 00:08:53,260
这边是“最近项目”

215
00:08:53,260 --> 00:08:55,060
我们往后构建的项目会出现在这里

216
00:08:55,060 --> 00:08:58,640
这边是我们创建新项目的地方

217
00:08:58,640 --> 00:09:01,520
选择第二个选项

218
00:09:01,520 --> 00:09:04,420
来创建一个新的 Xcode 项目

219
00:09:04,420 --> 00:09:07,370
就像我们之前提到的

220
00:09:07,370 --> 00:09:10,160
Xcode 不仅能用于构建 iOS
和手表（watchOS）的 app

221
00:09:10,160 --> 00:09:13,510
还包括 Apple TV（tvOS）
甚至 Mac（macOS）的 app

222
00:09:13,510 --> 00:09:16,820
我们将会重点教授
如何构建 iOS app

223
00:09:16,820 --> 00:09:19,221
但你们学到的 SwiftUI

224
00:09:19,221 --> 00:09:21,993
可以用于以上所有平台

225
00:09:23,190 --> 00:09:27,350
这些图标都代表不同的模版

226
00:09:27,350 --> 00:09:30,070
它们包含一些预设的代码

227
00:09:30,070 --> 00:09:33,890
可以协助你构建特定形式的 app

228
00:09:33,890 --> 00:09:36,140
对于这个学期所有的 app

229
00:09:36,140 --> 00:09:38,490
我们只需要选择 Single View App

230
00:09:38,490 --> 00:09:40,370
它是所有模版中最简易的

231
00:09:40,370 --> 00:09:42,450
它并不会生成

232
00:09:42,450 --> 00:09:44,640
很多代码

233
00:09:44,640 --> 00:09:46,870
我们双击它

234
00:09:46,870 --> 00:09:49,540
你现在要输入一些

235
00:09:49,540 --> 00:09:52,490
app 的基本信息
第一项是它的名字

236
00:09:52,490 --> 00:09:55,540
我叫它“记忆游戏”

237
00:09:55,540 --> 00:09:57,650
如果正在看的观众

238
00:09:57,650 --> 00:10:00,400
你也看过往期课程视频

239
00:10:00,400 --> 00:10:04,140
可能会发现

240
00:10:04,140 --> 00:10:07,870
我之前做过这个游戏

241
00:10:07,870 --> 00:10:11,630
但不是使用全新推出的 SwiftUI

242
00:10:11,630 --> 00:10:14,978
我称旧版为“翻牌游戏”（Concentration）
而新版为“记忆游戏”（Memorize）

243
00:10:14,978 --> 00:10:17,750
我用不同的名字称呼的原因在于

244
00:10:17,750 --> 00:10:21,330
以后可以通过名字来区分

245
00:10:21,330 --> 00:10:22,660
当我说“翻牌游戏”时

246
00:10:22,660 --> 00:10:26,450
我指的是之前的非 SwiftUI 版本

247
00:10:26,450 --> 00:10:28,920
这样做的好处在于

248
00:10:28,920 --> 00:10:31,530
能让那些已经初步涉足

249
00:10:31,530 --> 00:10:34,020
甚至已经熟练使用 UIKit 的人

250
00:10:34,020 --> 00:10:36,510
能够用 SwiftUI

251
00:10:36,510 --> 00:10:38,230
与之作对比

252
00:10:39,330 --> 00:10:41,560
这里的第二项 Team

253
00:10:41,560 --> 00:10:43,960
指的是你所属的开发者团队

254
00:10:43,960 --> 00:10:46,550
这里我选择
仅包含自己一人的开发者团队

255
00:10:46,550 --> 00:10:47,980
当你启动 Xcode

256
00:10:47,980 --> 00:10:51,150
你多半会在这里看到 Add Team 选项

257
00:10:51,150 --> 00:10:54,250
单击它后
你只需要一个 Apple ID

258
00:10:54,250 --> 00:10:56,100
来创建自己的开发者团队

259
00:10:56,100 --> 00:10:57,320
如果你是在为公司工作

260
00:10:57,320 --> 00:11:01,153
这里就会显示公司的开发团队

261
00:11:02,120 --> 00:11:05,430
这里的 Organization Name
就会是你的名字

262
00:11:05,430 --> 00:11:07,840
它会出现在文件的上方

263
00:11:07,840 --> 00:11:10,570
显示 written by CS193p Instructor
(由 CS193p 教师创建)

264
00:11:10,570 --> 00:11:12,660
所以你可以在此写上你的尊姓大名

265
00:11:12,660 --> 00:11:17,090
这里是你独一无二的标识符

266
00:11:17,090 --> 00:11:18,600
所以如果你是斯坦福的学生

267
00:11:18,600 --> 00:11:22,220
我建议你使用这个倒序的域名

268
00:11:22,220 --> 00:11:27,220
edu.stanford.<你的 SUNet ID>

269
00:11:27,900 --> 00:11:29,100
就足以起到辨识作用

270
00:11:29,100 --> 00:11:32,120
如果想的话
你也可以加入“CS193p”字样

271
00:11:32,120 --> 00:11:34,840
如果你是斯坦福的学生
加不加都关系不大

272
00:11:34,840 --> 00:11:37,520
如果你还不是斯坦福的学生

273
00:11:37,520 --> 00:11:40,440
你可以使用电子邮箱的倒序

274
00:11:40,440 --> 00:11:44,010
或者公司域名的倒序

275
00:11:44,010 --> 00:11:45,660
只要保持它是独一无二的就好

276
00:11:45,660 --> 00:11:46,880
你最好不要使用一些

277
00:11:46,880 --> 00:11:49,610
大概率被他人重复的标识符

278
00:11:49,610 --> 00:11:53,080
你会发现 Xcode 依据这两个选项

279
00:11:53,080 --> 00:11:55,460
自动生成了独一无二的标识符

280
00:11:55,460 --> 00:11:58,180
接下来我们选择编程语言

281
00:11:58,180 --> 00:12:01,737
iOS 的底层是

282
00:12:01,737 --> 00:12:04,202
使用 Objective-C 来编写的

283
00:12:04,202 --> 00:12:07,817
Objective-C 是 C 语言面向对象的版本

284
00:12:07,817 --> 00:12:10,450
但在大约五六年前
（注：2014 年）

285
00:12:10,450 --> 00:12:12,830
苹果公司引入了一门新的编程语言 Swift
（注：在 WWDC 14 公开）

286
00:12:12,830 --> 00:12:15,600
Swift 非常优秀
并能完全兼容

287
00:12:15,600 --> 00:12:16,680
Objective-C

288
00:12:16,680 --> 00:12:19,200
因此，它能直接使用现有的代码库

289
00:12:19,200 --> 00:12:22,190
Swift 也引入了许多
现代编程语言的特性

290
00:12:22,190 --> 00:12:25,030
不仅支持了面向对象式编程

291
00:12:25,030 --> 00:12:26,950
还特别支持了函数式编程

292
00:12:26,950 --> 00:12:29,860
Swift 支持这两者的特性

293
00:12:29,860 --> 00:12:31,690
也将会在 SwiftUI 中体现出来

294
00:12:31,690 --> 00:12:34,300
因为 SwiftUI 基于函数式编程
而非面向对象式编程

295
00:12:34,300 --> 00:12:36,890
我并没有足够的课时教授两门编程语言

296
00:12:36,890 --> 00:12:39,210
甚至很难教完一门

297
00:12:39,210 --> 00:12:41,700
所以我们接下来只会写 Swift

298
00:12:41,700 --> 00:12:46,290
当然，SwiftUI 是完全基于 Swift 的

299
00:12:46,290 --> 00:12:48,610
此处的 User Interface（用户界面）选项

300
00:12:48,610 --> 00:12:51,750
是用于选择使用旧式的

301
00:12:51,750 --> 00:12:54,450
非 SwiftUI 的方式开发

302
00:12:54,450 --> 00:12:58,170
我常将其称作 UIKit

303
00:12:59,190 --> 00:13:01,340
我们所有的开发工作都会用 SwiftUI 进行

304
00:13:01,340 --> 00:13:04,510
不过如果有时间的话
我会在这学期最后一两周

305
00:13:04,510 --> 00:13:06,240
给你展示一下

306
00:13:06,240 --> 00:13:09,390
如何把旧东西应用到 SwiftUI 中

307
00:13:09,390 --> 00:13:11,930
因为 SwiftUI 还不能实现所有

308
00:13:11,930 --> 00:13:13,130
旧版 UIKit 能做的事情

309
00:13:14,270 --> 00:13:16,710
所以我们需要把它们组合起来一起用

310
00:13:16,710 --> 00:13:19,440
SwiftUI 也提供了一些方法

311
00:13:19,440 --> 00:13:21,593
可以把 UIKit 里的东西组合进来

312
00:13:22,830 --> 00:13:24,680
在下面还有一些其他的选项

313
00:13:24,680 --> 00:13:26,760
在这学期末有空的话

314
00:13:26,760 --> 00:13:28,310
我们会学习 Core Data

315
00:13:28,310 --> 00:13:29,950
这是一个面向对象的数据库

316
00:13:29,950 --> 00:13:31,920
我希望能有时间教你们

317
00:13:31,920 --> 00:13:34,490
对于测试模块，很遗憾

318
00:13:34,490 --> 00:13:36,350
我可能没时间讲了

319
00:13:36,350 --> 00:13:39,460
我并没有“测试不重要”这种意思

320
00:13:39,460 --> 00:13:40,490
恰恰相反

321
00:13:40,490 --> 00:13:42,000
它非常重要

322
00:13:42,000 --> 00:13:44,350
只是如果你不知道如何开发

323
00:13:44,350 --> 00:13:46,040
你就没东西进行测试

324
00:13:46,040 --> 00:13:47,540
在我能回来讲这些东西之前

325
00:13:47,540 --> 00:13:49,730
我们的时间就已经用完了

326
00:13:49,730 --> 00:13:51,250
对于第一个作业来说

327
00:13:51,250 --> 00:13:52,280
没有关于这些东西的内容

328
00:13:52,280 --> 00:13:54,733
所以你可以不管它们

329
00:13:56,150 --> 00:13:58,114
现在我点 Next
然后 Xcode 弹出了一个窗口

330
00:13:58,114 --> 00:14:01,417
“行，很好，你想创建这个 app”

331
00:14:01,417 --> 00:14:02,810
“那你想把它放到哪里呢？”

332
00:14:02,810 --> 00:14:05,320
我强烈建议你把它放到 home 目录下的

333
00:14:05,320 --> 00:14:08,210
Developer 文件夹里

334
00:14:08,210 --> 00:14:12,710
这是我们放置文件的主要位置

335
00:14:12,710 --> 00:14:15,593
我非常建议你这样做

336
00:14:16,920 --> 00:14:17,890
在窗口下方

337
00:14:17,890 --> 00:14:20,560
你可以看到源代码控制（Source Control）

338
00:14:20,560 --> 00:14:21,613
对于不了解源代码控制的同学

339
00:14:21,613 --> 00:14:23,503
我这里简单介绍一下

340
00:14:23,503 --> 00:14:26,470
它是一种管理代码变化的工具

341
00:14:26,470 --> 00:14:28,580
例如添加代码和删除代码

342
00:14:28,580 --> 00:14:31,660
对于团队开发来说它非常有价值

343
00:14:31,660 --> 00:14:33,870
因为一个团队在同一份代码下工作

344
00:14:33,870 --> 00:14:36,740
很可能会出现冲突之类的各种问题

345
00:14:36,740 --> 00:14:41,070
所以你希望有一种仲裁这些变更的机制

346
00:14:41,070 --> 00:14:42,920
这里你勾不勾选都可以

347
00:14:42,920 --> 00:14:44,530
但我不会勾选它

348
00:14:44,530 --> 00:14:47,290
学期后面我会介绍一些

349
00:14:47,290 --> 00:14:49,090
Xcode 内集成的源代码控制

350
00:14:49,090 --> 00:14:50,830
的一些特性

351
00:14:50,830 --> 00:14:52,600
因为它非常酷

352
00:14:52,600 --> 00:14:55,290
但现在选不选都行

353
00:14:55,290 --> 00:14:57,930
现在我们的第一个 app 创建好了

354
00:14:57,930 --> 00:15:01,040
现在你们中有很多人

355
00:15:01,040 --> 00:15:02,920
还不太了解这个用户界面

356
00:15:02,920 --> 00:15:04,870
这个 Xcode 的用户界面

357
00:15:04,870 --> 00:15:07,190
所以我会简单介绍一下

358
00:15:07,190 --> 00:15:09,560
首先看左上角

359
00:15:09,560 --> 00:15:12,420
这一行按钮

360
00:15:12,420 --> 00:15:16,430
这是用来运行我们的应用程序的

361
00:15:16,430 --> 00:15:18,660
现在如果你点击这个按钮

362
00:15:18,660 --> 00:15:21,870
你会看到如果你有
一台设备连接到你的 Mac 上

363
00:15:21,870 --> 00:15:24,290
你就可以在这台设备上运行应用程序

364
00:15:24,290 --> 00:15:26,070
不过我现在并没有

365
00:15:26,070 --> 00:15:27,520
或者你可以在模拟器上运行

366
00:15:27,520 --> 00:15:29,530
这些模拟器非常棒

367
00:15:29,530 --> 00:15:31,310
它们完整地模拟了一台设备

368
00:15:31,310 --> 00:15:33,300
我马上就会展示给你看

369
00:15:33,300 --> 00:15:37,430
我这里选 iPhone 11 作为我的模拟器

370
00:15:37,430 --> 00:15:40,210
我可以通过点击 Play 按钮

371
00:15:40,210 --> 00:15:44,750
来运行这个模板创建的 SwiftUI 项目

372
00:15:44,750 --> 00:15:46,250
现在我点击了 Play 按钮

373
00:15:46,250 --> 00:15:47,770
模拟器启动了

374
00:15:47,770 --> 00:15:48,783
当你第一次启动的时候

375
00:15:48,783 --> 00:15:51,130
需要等待一段时间

376
00:15:51,130 --> 00:15:54,690
因为模拟器完全模拟了真实的设备

377
00:15:54,690 --> 00:15:55,750
我会给你展示这一点

378
00:15:55,750 --> 00:15:58,500
这就是我们的 app
它显示了一行字“Hello, World!”

379
00:15:58,500 --> 00:16:01,140
从旁边的代码你就能想象出来

380
00:16:01,140 --> 00:16:04,280
显示一行“Hello, World”
就是第一个 app 唯一能做的事情了

381
00:16:04,280 --> 00:16:06,390
但如果你从底部往上滑

382
00:16:06,390 --> 00:16:08,070
会看到 App 切换器

383
00:16:08,070 --> 00:16:11,990
就像真正的设备一样

384
00:16:11,990 --> 00:16:13,210
我可以进入设置

385
00:16:13,210 --> 00:16:14,380
这就是设置 app

386
00:16:14,380 --> 00:16:18,110
我可以设置这台设备

387
00:16:18,110 --> 00:16:20,610
这并不是一个 100% 完整的设备

388
00:16:20,610 --> 00:16:22,870
但这是确保 app 正常运行

389
00:16:22,870 --> 00:16:25,550
所需的部分

390
00:16:25,550 --> 00:16:27,920
不知道你是否注意到了

391
00:16:27,920 --> 00:16:30,580
这台设备刚巧处在深色模式（Dark Mode）

392
00:16:30,580 --> 00:16:33,110
这是 iOS 13 的新特性

393
00:16:33,110 --> 00:16:35,690
并且我打算留在深色模式

394
00:16:35,690 --> 00:16:37,300
因为我们要看看 app 在

395
00:16:37,300 --> 00:16:39,830
深色模式和非深色模式下的区别

396
00:16:39,830 --> 00:16:42,113
这些区别大部分都被 SwiftUI 自动处理了

397
00:16:43,607 --> 00:16:45,090
现在我回到 App 选择器

398
00:16:45,090 --> 00:16:46,370
回到我们的 app

399
00:16:46,370 --> 00:16:49,210
它显示了一行“Hello, World!”

400
00:16:49,210 --> 00:16:52,300
我们来看看

401
00:16:52,300 --> 00:16:54,330
这个 Hello World 是如何实现的

402
00:16:54,330 --> 00:16:56,170
现在我按下这个方形的按钮

403
00:16:56,170 --> 00:16:59,080
这是 Stop，用来停止模拟器

404
00:16:59,080 --> 00:17:02,070
现在我们继续参观 Xcode 的界面

405
00:17:02,070 --> 00:17:05,610
在左边的蓝色区域

406
00:17:05,610 --> 00:17:07,603
我们称它为导航器（Navigator）

407
00:17:07,603 --> 00:17:09,570
你可以调整它的大小

408
00:17:09,570 --> 00:17:12,180
通过点击这里的文件

409
00:17:12,180 --> 00:17:14,510
就能在不同文件间跳转

410
00:17:14,510 --> 00:17:15,840
同时在上方

411
00:17:15,840 --> 00:17:17,530
它还提供了其他导航方式

412
00:17:17,530 --> 00:17:20,080
例如你可以在这里搜索

413
00:17:20,080 --> 00:17:23,140
还可以在调试器（Debugger）中
查看断点（Breakpoint）

414
00:17:23,140 --> 00:17:25,700
在这里还可以查看之前的编译结果

415
00:17:25,700 --> 00:17:28,280
例如之前的输出等等

416
00:17:28,280 --> 00:17:31,110
所以你真的会习惯于

417
00:17:31,110 --> 00:17:33,330
用导航器在项目中移动

418
00:17:33,330 --> 00:17:36,390
找到你想要的东西

419
00:17:36,390 --> 00:17:39,850
在右手边有一块灰色区域

420
00:17:39,850 --> 00:17:42,090
叫做实用工具（Utilities）窗口

421
00:17:42,090 --> 00:17:44,620
有时候我们也叫它检查器（Inspector）

422
00:17:44,620 --> 00:17:47,240
不过我们前几节课

423
00:17:47,240 --> 00:17:48,680
并不需要用到它

424
00:17:48,680 --> 00:17:51,430
所以我想趁这个机会告诉你

425
00:17:51,430 --> 00:17:53,160
如何隐藏它

426
00:17:53,160 --> 00:17:56,460
你可以看到右上角有三个按钮

427
00:17:56,460 --> 00:17:59,963
它们可以隐藏和显示这些面板

428
00:18:00,920 --> 00:18:03,270
我会把实用工具隐藏起来

429
00:18:03,270 --> 00:18:05,550
因为我刚说过了，我们不需要这东西

430
00:18:05,550 --> 00:18:07,040
你看这第三个按钮

431
00:18:07,040 --> 00:18:09,530
它会让底部弹出一些东西

432
00:18:09,530 --> 00:18:14,080
它们是调试器和
控制台（Console）输出

433
00:18:14,080 --> 00:18:16,640
我倾向于隐藏它们

434
00:18:16,640 --> 00:18:19,340
因为在不做调试的时候

435
00:18:19,340 --> 00:18:20,800
它们会浪费屏幕空间

436
00:18:20,800 --> 00:18:24,310
同时它们会在你需要的时候自己弹出来

437
00:18:24,310 --> 00:18:26,700
例如运行到断点的时候

438
00:18:26,700 --> 00:18:29,283
或者控制台有输出的时候

439
00:18:30,480 --> 00:18:33,850
这个区域是主编辑窗口

440
00:18:33,850 --> 00:18:36,520
现在它被分成了两块

441
00:18:36,520 --> 00:18:40,090
你也可以通过点击这个小加号按钮

442
00:18:40,090 --> 00:18:42,470
来分割更多区域

443
00:18:42,470 --> 00:18:45,380
它能在右边添加另一个
也就是第三个编辑器

444
00:18:45,380 --> 00:18:47,890
如果你希望上下排列的话

445
00:18:47,890 --> 00:18:50,863
你甚至可以在下方添加一个编辑器

446
00:18:51,710 --> 00:18:56,390
这就是对 Xcode 界面的介绍了

447
00:18:56,390 --> 00:18:58,880
当然上面还有一大堆菜单项

448
00:18:58,880 --> 00:19:02,150
随着课程进行我们会渐渐学习它们

449
00:19:02,150 --> 00:19:04,616
现在我们聚焦于主编辑窗口

450
00:19:04,616 --> 00:19:05,740
来看看我们的代码

451
00:19:05,740 --> 00:19:08,900
这里有个文件叫 ContentView.swift

452
00:19:08,900 --> 00:19:10,140
这是一个 Swift 文件

453
00:19:10,140 --> 00:19:12,720
这是你第一次见到这门语言

454
00:19:12,720 --> 00:19:15,730
我们先看这一小段代码

455
00:19:15,730 --> 00:19:17,740
它们的作用是

456
00:19:17,740 --> 00:19:19,900
将你写的代码

457
00:19:19,900 --> 00:19:22,720
关联到

458
00:19:22,720 --> 00:19:24,670
右边这个区域

459
00:19:24,670 --> 00:19:26,980
这个叫做预览（Preview）的窗口

460
00:19:26,980 --> 00:19:30,020
看这里写着“自动更新已暂停”
Automatic preview updating paused

461
00:19:30,020 --> 00:19:31,900
当然，我们依旧有模拟器

462
00:19:31,900 --> 00:19:33,507
可以用来查看程序我们的程序

463
00:19:33,507 --> 00:19:34,840
运行起来的样子

464
00:19:34,840 --> 00:19:38,140
但我们也可以通过点这个 Resume

465
00:19:38,140 --> 00:19:43,020
来恢复用户界面的实时预览

466
00:19:43,020 --> 00:19:46,240
它会编译我们的代码

467
00:19:46,240 --> 00:19:49,000
然后在这里运行

468
00:19:49,000 --> 00:19:51,090
它看起来有点像个 iPhone

469
00:19:51,090 --> 00:19:52,940
注意这台设备不在深色模式下

470
00:19:52,940 --> 00:19:55,260
所以是白底黑字

471
00:19:55,260 --> 00:19:58,730
这是 SwiftUI 自动做的深色模式适配

472
00:19:58,730 --> 00:20:00,360
我们还可以调整预览窗口的大小

473
00:20:00,360 --> 00:20:03,100
让它在这边少占一点空间

474
00:20:03,100 --> 00:20:07,180
因为这段代码只是“胶水代码”

475
00:20:07,180 --> 00:20:09,690
所以我不会把注意力放在它身上

476
00:20:09,690 --> 00:20:12,750
因此我要（多敲几个空行）
把它从屏幕上隐藏

477
00:20:12,750 --> 00:20:14,700
当像这样有大量代码变更的时候

478
00:20:14,700 --> 00:20:16,640
或者把代码四处移动之后

479
00:20:16,640 --> 00:20:18,890
预览有时候会暂停

480
00:20:18,890 --> 00:20:20,130
你看，它又暂停了

481
00:20:20,130 --> 00:20:22,350
问题不大，点下 Resume 恢复

482
00:20:22,350 --> 00:20:23,860
但其他大部分的编辑

483
00:20:23,860 --> 00:20:25,600
比如把这个 "Hello, world!"

484
00:20:25,600 --> 00:20:29,320
修改为 "Hello There, World!"

485
00:20:29,320 --> 00:20:31,930
你可以看到预览是实时更新的

486
00:20:31,930 --> 00:20:33,750
所以代码改动的类型决定了

487
00:20:33,750 --> 00:20:35,660
是会暂停预览

488
00:20:35,660 --> 00:20:38,690
还是让预览实时更新

489
00:20:38,690 --> 00:20:40,900
当然，你依然可以选择使用模拟器

490
00:20:40,900 --> 00:20:41,980
特别是如果你想

491
00:20:41,980 --> 00:20:45,180
查看在不同设备上运行效果的时候等

492
00:20:45,180 --> 00:20:47,680
你总是可以通过这上面选择模拟器运行

493
00:20:49,180 --> 00:20:51,127
现在让我们看 Swift 代码

494
00:20:51,127 --> 00:20:53,227
这就是我们程序特有的

495
00:20:53,227 --> 00:20:54,553
全部 Swift 代码了

496
00:20:54,553 --> 00:20:57,000
还有些样板代码

497
00:20:57,000 --> 00:20:59,220
在这两个 Delegate 文件里

498
00:20:59,220 --> 00:21:00,260
我们之后会去查看

499
00:21:00,260 --> 00:21:03,090
但这几乎是实现这个“Hello World”

500
00:21:03,090 --> 00:21:06,380
程序所需要的全部代码了

501
00:21:06,380 --> 00:21:09,250
现在让我们来仔细看看这些 Swift 代码

502
00:21:09,250 --> 00:21:11,950
首先我们有
import SwiftUI

503
00:21:11,950 --> 00:21:15,330
我觉得你们能猜出来这是在干什么

504
00:21:15,330 --> 00:21:18,960
它就像其他语言的 include 或者 import

505
00:21:18,960 --> 00:21:22,090
它导入了一个软件包（Package）

506
00:21:22,090 --> 00:21:24,520
软件包的名称叫做 SwiftUI

507
00:21:24,520 --> 00:21:27,369
那是苹果公司提供的一个庞大的软件包

508
00:21:27,369 --> 00:21:30,130
它实现了整个 SwiftUI

509
00:21:30,130 --> 00:21:32,640
所以当我们在编写用户界面的时候

510
00:21:32,640 --> 00:21:35,150
我们总是会 import SwiftUI

511
00:21:35,150 --> 00:21:36,870
有的时候我们写的代码

512
00:21:36,870 --> 00:21:38,450
不是关于用户界面的

513
00:21:38,450 --> 00:21:41,280
或者说有意地独立于用户界面

514
00:21:41,280 --> 00:21:43,963
那种情况下就不应该 import SwiftUI

515
00:21:43,963 --> 00:21:45,670
我们会导入另一个软件包

516
00:21:45,670 --> 00:21:47,410
Foundation（基础框架）

517
00:21:47,410 --> 00:21:51,200
Foundation 扩展了基础类型，比如
Array、Dictionary、String 等

518
00:21:51,200 --> 00:21:53,670
SwiftUI 也使用了 Foundation 软件包

519
00:21:53,670 --> 00:21:54,910
所以导入 SwiftUI 的时候

520
00:21:54,910 --> 00:21:57,253
也自动导入了 Foundation

521
00:21:58,190 --> 00:22:01,670
所以我们整个程序就这么三行代码

522
00:22:01,670 --> 00:22:03,100
（如果不算这些括号的话）

523
00:22:03,100 --> 00:22:05,110
所以我们来仔细分析一下

524
00:22:05,110 --> 00:22:07,600
首先是关键字

525
00:22:07,600 --> 00:22:10,930
你可以看到，所有的 Swift 关键字
是紫红色的

526
00:22:10,930 --> 00:22:12,800
方便我们区分 Swift 语言本身的东西

527
00:22:12,800 --> 00:22:15,050
和我们的代码

528
00:22:15,050 --> 00:22:16,220
然后这是一个 struct（结构体）

529
00:22:16,220 --> 00:22:18,060
这里用 struct 声明了一个结构体

530
00:22:18,060 --> 00:22:21,421
我知道你可能在其他语言中用过结构体

531
00:22:21,421 --> 00:22:25,417
像 C 和 C++ 这样的语言都有结构体

532
00:22:25,417 --> 00:22:29,230
Swift 里的结构体和其他语言类似

533
00:22:29,230 --> 00:22:31,970
能存储一些变量

534
00:22:31,970 --> 00:22:35,650
但其实 Swift 里的结构体功能更强大

535
00:22:35,650 --> 00:22:38,500
除了存储变量之外

536
00:22:38,500 --> 00:22:39,701
还可以有方法

537
00:22:39,701 --> 00:22:42,100
它们还能实现（协议规定的）行为

538
00:22:42,100 --> 00:22:44,270
我们也会马上

539
00:22:44,270 --> 00:22:45,880
在这里看到

540
00:22:45,880 --> 00:22:48,520
所以这个结构体的名字叫做 ContentView

541
00:22:48,520 --> 00:22:51,850
总结一下，我们声明的标识符是绿色的

542
00:22:51,850 --> 00:22:54,040
内置的标识符是紫色的

543
00:22:54,040 --> 00:22:56,280
然后 Swift 的关键字是紫红色的

544
00:22:56,280 --> 00:22:58,350
那么我们结构体的名字是 ContentView

545
00:22:58,350 --> 00:23:01,800
但这里就是这个结构体声明里

546
00:23:01,800 --> 00:23:04,000
比较有意思的地方了

547
00:23:04,000 --> 00:23:06,380
它的意思是这个结构体

548
00:23:06,380 --> 00:23:10,330
会有和 View 一样行为

549
00:23:10,330 --> 00:23:14,770
或者说能够作为 View 使用

550
00:23:14,770 --> 00:23:18,370
也可以说它“是一个”View

551
00:23:18,370 --> 00:23:22,830
但如果我用了“ContentView 是一个 View”
这样的说法

552
00:23:22,830 --> 00:23:25,610
可能会让有的人想到面向对象编程

553
00:23:25,610 --> 00:23:27,410
认为 View 是个超类

554
00:23:27,410 --> 00:23:28,440
但其实不然

555
00:23:28,440 --> 00:23:29,860
This is not object-oriented programming.

556
00:23:29,860 --> 00:23:31,450
This is functional programming.

557
00:23:31,450 --> 00:23:33,410
And that's why we may be more likely

558
00:23:33,410 --> 00:23:36,680
to say something like a
ContentView functions like a View

559
00:23:36,680 --> 00:23:39,290
or it behaves like a View.

560
00:23:39,290 --> 00:23:41,330
And this is super important.

561
00:23:41,330 --> 00:23:44,680
This behavior, View, is crucial

562
00:23:44,680 --> 00:23:47,810
to how all of SwiftUI
works as you will see.

563
00:23:47,810 --> 00:23:49,950
We are going to be using so many Views

564
00:23:49,950 --> 00:23:53,320
in the next couple of lectures,
you can't even imagine it.

565
00:23:53,320 --> 00:23:55,730
And we're gonna talk
all about the concepts

566
00:23:55,730 --> 00:23:59,110
behind this behavior specification

567
00:23:59,110 --> 00:24:01,650
using slides at the
beginning of lecture two.

568
00:24:01,650 --> 00:24:03,870
In the meantime, we're
just going to understand

569
00:24:03,870 --> 00:24:07,133
that this means that
ContentView behaves like a View.

570
00:24:07,980 --> 00:24:11,390
A View is just a
rectangular area on screen.

571
00:24:11,390 --> 00:24:14,280
So here I've put my mouse on this Text

572
00:24:14,280 --> 00:24:15,853
and it's selected it
over here in the preview.

573
00:24:15,853 --> 00:24:19,970
And you can see it's put this
blue border around that Text.

574
00:24:19,970 --> 00:24:22,310
That blue border is bordering this View.

575
00:24:22,310 --> 00:24:25,210
So a Text, it also behaves like a View.

576
00:24:25,210 --> 00:24:26,520
It "is a" View.

577
00:24:26,520 --> 00:24:28,120
And so you're seeing it right here.

578
00:24:28,120 --> 00:24:29,440
So that's all Views are.

579
00:24:29,440 --> 00:24:31,610
They're rectangular areas on screen,

580
00:24:31,610 --> 00:24:34,560
both for drawing and also for multi-touch.

581
00:24:34,560 --> 00:24:37,870
For swipes and taps, pinches,

582
00:24:37,870 --> 00:24:41,120
those kinds of things
happen in these rectangles.

583
00:24:41,120 --> 00:24:42,640
So that's what a View is.

584
00:24:42,640 --> 00:24:44,670
So when something behaves like a View,

585
00:24:44,670 --> 00:24:46,330
it's a rectangular area on screen.

586
00:24:46,330 --> 00:24:49,250
So our ContentView which
behaves like a View

587
00:24:49,250 --> 00:24:51,900
is this entire rectangle.

588
00:24:51,900 --> 00:24:54,640
The whole rectangle that fills the screen

589
00:24:54,640 --> 00:24:56,173
is our ContentView.

590
00:24:57,296 --> 00:24:59,890
All right, if you are somebody,

591
00:24:59,890 --> 00:25:02,260
some struct like this ContentView,

592
00:25:02,260 --> 00:25:05,320
and you want to say that
you behave like a View,

593
00:25:05,320 --> 00:25:10,320
you must in your struct
have this var right here,

594
00:25:10,360 --> 00:25:12,850
this var called body.

595
00:25:12,850 --> 00:25:14,330
I'll select it for you here.

596
00:25:14,330 --> 00:25:17,190
So here's the declaration of var body.

597
00:25:17,190 --> 00:25:20,890
So Swift variables, they
have the keyword var,

598
00:25:20,890 --> 00:25:22,210
short for variable.

599
00:25:22,210 --> 00:25:24,910
Although we don't tend to call variables

600
00:25:24,910 --> 00:25:27,700
inside a struct like this vars.

601
00:25:27,700 --> 00:25:29,770
We call them properties.

602
00:25:29,770 --> 00:25:32,870
So you're gonna hear me use
the word property all the time.

603
00:25:32,870 --> 00:25:36,010
It means a var inside a struct or a class.

604
00:25:36,010 --> 00:25:38,120
Also, if we're doing
object-oriented programming,

605
00:25:38,120 --> 00:25:40,210
we call them properties.

606
00:25:40,210 --> 00:25:44,680
你可以很容易地使用 var 关键字
来声明一个属性

607
00:25:44,680 --> 00:25:46,487
此处的 body 是属性的名称

608
00:25:46,487 --> 00:25:49,410
它的字体颜色也是绿色
因为这是我们声明的（而非系统声明）

609
00:25:49,410 --> 00:25:54,410
这里的 some View 是属性的类型

610
00:25:55,400 --> 00:25:57,290
或者说是这个变量的类型

611
00:25:57,290 --> 00:26:01,020
即使在 Swift 这门语言中
它也是一种相当有趣的类型

612
00:26:01,020 --> 00:26:04,000
因为它包含一个紫红色字体所代表的

613
00:26:04,000 --> 00:26:06,083
Swift 定义的关键字

614
00:26:07,000 --> 00:26:10,640
这里通常会是一个 Int 类型的变量

615
00:26:10,640 --> 00:26:12,910
或是一个 String 类型的变量

616
00:26:12,910 --> 00:26:15,180
也或许是个布尔值

617
00:26:15,180 --> 00:26:17,350
是个 Array 类型的变量之类的

618
00:26:17,350 --> 00:26:20,940
但在我们的示例程序中

619
00:26:20,940 --> 00:26:23,450
它是这个耐人寻味的类型：some View

620
00:26:23,450 --> 00:26:24,333
说到底

621
00:26:24,333 --> 00:26:28,820
这个变量，或者说这个属性的类型

622
00:26:28,820 --> 00:26:33,820
可以是任何一种类型，任何一种结构体
只要表现得像一个 View 就行

623
00:26:34,830 --> 00:26:36,883
也就是说，它只要是某一种 View 就行

624
00:26:38,180 --> 00:26:41,450
这就是这个古怪的类型

625
00:26:41,450 --> 00:26:42,580
在这里所代表的含义

626
00:26:42,580 --> 00:26:45,200
因此，如果你想表现的像 View

627
00:26:45,200 --> 00:26:47,480
你必须有一个叫 body 的变量

628
00:26:47,480 --> 00:26:51,674
它是另一个表现得
像个 View 一样的东西

629
00:26:51,674 --> 00:26:53,977
你可能会想：“什么”

630
00:26:53,977 --> 00:26:54,810
“那真是怪了”

631
00:26:54,810 --> 00:26:57,497
“因此要成为一个 View ”

632
00:26:57,497 --> 00:27:00,017
“我就必须有另一个 View
作为我的 body 吗？”

633
00:27:00,017 --> 00:27:01,357
“那讲不通啊”

634
00:27:01,357 --> 00:27:05,460
但是你可以
把 View 当做乐高玩具

635
00:27:05,460 --> 00:27:07,580
乐高里有一些基础砖块

636
00:27:07,580 --> 00:27:11,170
那些积木就像 Text 一样
是基础的东西

637
00:27:11,170 --> 00:27:13,330
Text 就像基础砖块一样

638
00:27:13,330 --> 00:27:16,930
你可以将乐高积木
拼成其他的东西

639
00:27:16,930 --> 00:27:18,830
你可以把你拼出来的东西

640
00:27:18,830 --> 00:27:20,590
叫做新乐高

641
00:27:20,590 --> 00:27:24,350
就像一个新组成的乐高
或者一个更强大的乐高

642
00:27:24,350 --> 00:27:26,520
例如，如果你想要
建造一个乐高房子

643
00:27:26,520 --> 00:27:29,140
你可能会做
小乐高家具

644
00:27:29,140 --> 00:27:32,030
乐高沙发，乐高餐桌

645
00:27:32,030 --> 00:27:33,800
所有的这些东西都来自于其他的乐高

646
00:27:33,800 --> 00:27:36,030
And if you consider that
couch and the kitchen table

647
00:27:36,030 --> 00:27:38,570
as Legos, then you're
putting those together

648
00:27:38,570 --> 00:27:39,403
to make the house.

649
00:27:39,403 --> 00:27:42,280
You could even then
have the house be a Lego

650
00:27:42,280 --> 00:27:45,370
that you put together to
make a Lego neighborhood.

651
00:27:45,370 --> 00:27:48,600
Or the Lego world, Lego universe.

652
00:27:48,600 --> 00:27:52,150
That's the way we wanna
think of making these Views.

653
00:27:52,150 --> 00:27:54,210
Now, the difference
between a Lego and a View

654
00:27:54,210 --> 00:27:56,510
is that there are special kinds of Views

655
00:27:56,510 --> 00:27:59,050
that are used to combine Legos.

656
00:27:59,050 --> 00:28:01,807
We've got these basic
brick Legos like Text.

657
00:28:01,807 --> 00:28:03,900
And then we've got other kinds of Views

658
00:28:03,900 --> 00:28:07,340
that are combiners, Lego
combiners, View combiners.

659
00:28:07,340 --> 00:28:11,100
And you're gonna see us
use those in detail here.

660
00:28:11,100 --> 00:28:13,040
That's why our body just returns

661
00:28:13,040 --> 00:28:17,120
one single some View of some sort.

662
00:28:17,120 --> 00:28:19,670
It might be returning a combiner.

663
00:28:19,670 --> 00:28:21,090
If it returns a combiner View,

664
00:28:21,090 --> 00:28:24,180
then it could have tons
and tons of Views inside

665
00:28:24,180 --> 00:28:25,333
that are combined.

666
00:28:26,620 --> 00:28:30,530
Now, this is also a kind
of an interesting var here

667
00:28:30,530 --> 00:28:34,010
in that it's got this
curly brace thing after it.

668
00:28:34,010 --> 00:28:37,750
This var, its value is
not stored in memory.

669
00:28:37,750 --> 00:28:41,000
Instead this var is computed.

670
00:28:41,000 --> 00:28:44,900
So every time someone, namely the system,

671
00:28:44,900 --> 00:28:47,030
asks for the value of this var,

672
00:28:47,030 --> 00:28:50,810
this code in this curly
brace gets executed.

673
00:28:50,810 --> 00:28:53,090
And whatever the value that's returned,

674
00:28:53,090 --> 00:28:54,680
that's what the value of the body is.

675
00:28:54,680 --> 00:28:57,080
And every time it's called,
it gets called again,

676
00:28:57,080 --> 00:28:58,920
it's constantly calling this thing.

677
00:28:58,920 --> 00:29:01,770
Now, this code in here
seems kind of minimalistic

678
00:29:01,770 --> 00:29:03,330
but it'll probably make more sense

679
00:29:03,330 --> 00:29:05,720
if I put this keyword back.

680
00:29:05,720 --> 00:29:08,050
This keyword, return, you see is magenta.

681
00:29:08,050 --> 00:29:10,450
It's a Swift thing, it means return.

682
00:29:10,450 --> 00:29:13,280
Return a value from this piece of code,

683
00:29:13,280 --> 00:29:15,540
this little curly-braced piece of code.

684
00:29:15,540 --> 00:29:20,160
And it wasn't there because
Swift loves to leave things out

685
00:29:20,160 --> 00:29:22,440
and make it so you have to type
as little code as possible.

686
00:29:22,440 --> 00:29:23,990
You're gonna see that later.

687
00:29:23,990 --> 00:29:27,000
And so if you have a
one-line function like this

688
00:29:27,000 --> 00:29:29,530
that returns a value,
so that's what this is,

689
00:29:29,530 --> 00:29:32,320
a one-liner returns this Text thing.

690
00:29:32,320 --> 00:29:34,910
Then you can leave this return out.

691
00:29:34,910 --> 00:29:36,250
It'll just infer that.

692
00:29:36,250 --> 00:29:38,263
But I'm gonna leave it in

693
00:29:38,263 --> 00:29:40,220
because I want you to realize

694
00:29:40,220 --> 00:29:41,290
that that's what's going on here.

695
00:29:41,290 --> 00:29:43,570
We have this little piece of code,

696
00:29:43,570 --> 00:29:46,450
it returns this Text thing.

697
00:29:46,450 --> 00:29:49,020
And that's going to always
be the value of body.

698
00:29:49,020 --> 00:29:51,460
Anytime someone asks me
for the value of body,

699
00:29:51,460 --> 00:29:54,853
it's gonna execute this and
return this Text right here.

700
00:29:55,710 --> 00:29:59,490
Now, this return type,
remember, is some View.

701
00:29:59,490 --> 00:30:02,137
So if you're saying, "It's returning Text.

702
00:30:02,137 --> 00:30:03,270
"What's going on here?"

703
00:30:03,270 --> 00:30:07,750
Well, of course Text, it
says it behaves like a View.

704
00:30:07,750 --> 00:30:09,070
So this is "some View".

705
00:30:09,070 --> 00:30:12,110
In other words, somewhere
off in Apple's code

706
00:30:12,110 --> 00:30:13,607
there is some line that looks like this.

707
00:30:13,607 --> 00:30:18,310
"struct Text behaves like a View."

708
00:30:18,310 --> 00:30:23,160
And that's why we can return
a Text as the value of body

709
00:30:23,160 --> 00:30:23,993
'cause it's some View.

710
00:30:23,993 --> 00:30:26,700
In fact, we could even
just type Text right here.

711
00:30:26,700 --> 00:30:30,800
That would be valid because
to behave like a View,

712
00:30:30,800 --> 00:30:35,460
your var body just has to
return something that is a View.

713
00:30:35,460 --> 00:30:37,830
And of course, Text is a View.

714
00:30:37,830 --> 00:30:40,080
So why don't we type Text?

715
00:30:40,080 --> 00:30:42,320
Why do we do this some View?

716
00:30:42,320 --> 00:30:46,300
Well, as our body of our
View gets more complicated

717
00:30:46,300 --> 00:30:48,170
and we start using these View-combiners

718
00:30:48,170 --> 00:30:50,900
and things like that, it's
gonna be constantly changing.

719
00:30:50,900 --> 00:30:53,430
Which kind of View we're returning.

720
00:30:53,430 --> 00:30:54,870
Right now we're returning a Text.

721
00:30:54,870 --> 00:30:56,500
But eventually we're gonna be returning

722
00:30:56,500 --> 00:30:58,780
View-combining Views.

723
00:30:58,780 --> 00:31:02,530
And we wanna let the compiler
figure it out for us.

724
00:31:02,530 --> 00:31:06,187
So this some View is basically
saying to the compiler,

725
00:31:06,187 --> 00:31:08,867
"Go look in my code right here.

726
00:31:08,867 --> 00:31:10,867
"Figure out what it's returning.

727
00:31:10,867 --> 00:31:13,897
"Make sure that it behaves like a View.

728
00:31:13,897 --> 00:31:16,597
"And then use that as
the type of the body."

729
00:31:17,450 --> 00:31:20,310
You're gonna find as we
go through this course

730
00:31:20,310 --> 00:31:24,060
that Swift is what's called a
very strongly-typed language.

731
00:31:24,060 --> 00:31:28,050
That means every variable
has a specific type.

732
00:31:28,050 --> 00:31:30,580
It's not a language
like JavaScript or other

733
00:31:30,580 --> 00:31:32,230
where it's like well, the variable

734
00:31:32,230 --> 00:31:33,850
depends on what you assign to it.

735
00:31:33,850 --> 00:31:34,683
That's when it gets ...

736
00:31:34,683 --> 00:31:38,250
No, in Swift, every
variable has a specific type

737
00:31:38,250 --> 00:31:39,610
and always has a value.

738
00:31:39,610 --> 00:31:43,963
That's just fundamental
to the way Swift works.

739
00:31:45,740 --> 00:31:49,060
So let's look at this Text right here.

740
00:31:49,060 --> 00:31:51,320
We create this Text.

741
00:31:51,320 --> 00:31:53,680
Anytime we're creating
anything, any struct,

742
00:31:53,680 --> 00:31:56,680
so a Text is just a struct
that behaves like a View.

743
00:31:56,680 --> 00:32:00,120
And anytime we create
one, we in parentheses

744
00:32:00,120 --> 00:32:03,700
give it whatever information
it needs to create itself.

745
00:32:03,700 --> 00:32:05,840
Now, obviously for a Text,

746
00:32:05,840 --> 00:32:09,007
it needs the string that it's
going to use to create itself.

747
00:32:09,007 --> 00:32:11,460
and that's why you get
this "Hello There, World!"

748
00:32:11,460 --> 00:32:14,140
And notice if I edit this,
it's not changing this.

749
00:32:14,140 --> 00:32:16,080
That's because it's paused up here.

750
00:32:16,080 --> 00:32:18,720
But if I resume, then it's going

751
00:32:18,720 --> 00:32:23,303
and now I can for example
type, and it's tracking it.

752
00:32:24,250 --> 00:32:28,010
So this is always the way we
create new structs of any kind.

753
00:32:28,010 --> 00:32:30,030
We put parentheses after it

754
00:32:30,030 --> 00:32:32,100
and then we give it
whatever arguments it wants.

755
00:32:32,100 --> 00:32:34,040
And some things when you're creating them,

756
00:32:34,040 --> 00:32:35,420
can take different kinds of arguments

757
00:32:35,420 --> 00:32:36,361
depending on what they are.

758
00:32:36,361 --> 00:32:38,511
And you're gonna see
that pretty soon here.

759
00:32:40,740 --> 00:32:43,960
So let's see if we can start building

760
00:32:43,960 --> 00:32:48,090
a UI that looks a little
bit more like a card.

761
00:32:48,090 --> 00:32:49,510
Right now it just says, "Hello, World!"

762
00:32:49,510 --> 00:32:53,550
Let's remind ourselves what
that's gonna look like.

763
00:32:53,550 --> 00:32:55,730
Kind of a screen capture of the game

764
00:32:55,730 --> 00:32:57,670
that I showed you earlier.

765
00:32:57,670 --> 00:33:01,210
And our cards, they kind of
have these rounded rectangles

766
00:33:01,210 --> 00:33:03,030
around the edge, you see that?

767
00:33:03,030 --> 00:33:04,470
And this is a line.

768
00:33:04,470 --> 00:33:06,040
Then kind of a white background.

769
00:33:06,040 --> 00:33:08,010
They have an emoji on the front.

770
00:33:08,010 --> 00:33:10,630
So let's take care of
each of these things.

771
00:33:10,630 --> 00:33:11,710
Let's start with the emoji.

772
00:33:11,710 --> 00:33:13,000
That's gonna be really easy

773
00:33:13,000 --> 00:33:15,420
'cause an emoji is just a piece of text.

774
00:33:15,420 --> 00:33:17,160
So I'm gonna delete that.

775
00:33:17,160 --> 00:33:19,840
I don't know if you know
this but in any Mac app,

776
00:33:19,840 --> 00:33:22,850
if you go to the Edit menu,
go down to the bottom,

777
00:33:22,850 --> 00:33:24,891
there'll be Emoji &amp; Symbols.

778
00:33:24,891 --> 00:33:26,460
You see there, I can get an emoji.

779
00:33:26,460 --> 00:33:29,090
You can even search ghost.

780
00:33:29,090 --> 00:33:30,040
There it is, ghost.

781
00:33:30,940 --> 00:33:32,280
Let's double-click on it.

782
00:33:32,280 --> 00:33:33,120
Now we have a ghost.

783
00:33:33,120 --> 00:33:34,360
And sure enough, there's our ghost.

784
00:33:34,360 --> 00:33:35,690
He's really small.

785
00:33:35,690 --> 00:33:38,400
Although we can zoom in and see him there.

786
00:33:38,400 --> 00:33:40,370
And we're gonna have to
fix that he's so small.

787
00:33:40,370 --> 00:33:41,810
It's not gonna work for our cards

788
00:33:41,810 --> 00:33:43,100
for him to be so tiny like that.

789
00:33:43,100 --> 00:33:44,973
But one thing at a time.

790
00:33:45,930 --> 00:33:48,760
The next thing we need
is our rounded rectangle.

791
00:33:48,760 --> 00:33:50,610
So we need this rounded
rectangle, it goes up there.

792
00:33:50,610 --> 00:33:53,490
So let's comment this Text out.

793
00:33:53,490 --> 00:33:55,470
So I'm doing Command
slash by the way there

794
00:33:55,470 --> 00:33:57,290
to comment that Text out.

795
00:33:57,290 --> 00:34:01,180
And instead put our
rounded rectangle in there.

796
00:34:01,180 --> 00:34:04,000
Luckily, Swift has an awesome thing here.

797
00:34:04,000 --> 00:34:07,760
RoundedRectangle 正是我们想要的

798
00:34:07,760 --> 00:34:10,200
和之前我们创建 Text 一样

799
00:34:10,200 --> 00:34:12,850
我们必须提供一些信息

800
00:34:12,850 --> 00:34:14,790
来创建一个 RoundedRectangle

801
00:34:14,790 --> 00:34:17,980
你可以通过以下方法
轻松地知道需要补充什么

802
00:34:17,980 --> 00:34:20,290
只需输入左括号 (

803
00:34:20,290 --> 00:34:22,170
Xcode 便会向你展示各种选项

804
00:34:22,170 --> 00:34:24,820
可以看到，共有四种方式

805
00:34:24,820 --> 00:34:26,197
用来创建 RoundRectangle

806
00:34:26,197 --> 00:34:29,350
你可以指定圆角的半径
或者圆角的尺寸

807
00:34:29,350 --> 00:34:31,770
也就是圆角的宽和高

808
00:34:31,770 --> 00:34:33,340
接下来我用
cornerRadius 作为示范

809
00:34:33,340 --> 00:34:37,363
你可以按下 Tab 键
或者鼠标双击这里

810
00:34:38,970 --> 00:34:43,040
接着，它会提示你输入半径
以磅（point）为单位

811
00:34:43,040 --> 00:34:45,235
输入 10 磅

812
00:34:45,235 --> 00:34:48,050
一磅与字体的磅值
是相同的标准

813
00:34:48,050 --> 00:34:49,830
比如 10 磅大小的字体

814
00:34:49,830 --> 00:34:53,780
举个例子，方便你们感受一磅有多大

815
00:34:53,780 --> 00:34:57,550
一台 iPhone 的宽度大约四五百磅

816
00:34:57,550 --> 00:35:00,230
高度大约七八百磅

817
00:35:00,230 --> 00:35:05,230
An iPad might be 1,000
by 700 and something.

818
00:35:05,580 --> 00:35:08,070
Now, I'm being intentionally vague here

819
00:35:08,070 --> 00:35:10,710
because we never write our code

820
00:35:10,710 --> 00:35:13,830
trying to know what the
sizes of screens are.

821
00:35:13,830 --> 00:35:16,050
SwiftUI helps us write code

822
00:35:16,050 --> 00:35:17,450
that works on any size screen.

823
00:35:17,450 --> 00:35:20,010
It just adapts and adjusts
to any size screen.

824
00:35:20,010 --> 00:35:22,530
You're really gonna see
that with our Memorize game

825
00:35:22,530 --> 00:35:25,430
when we start having rows
and columns of buttons.

826
00:35:25,430 --> 00:35:27,740
On big screens they're gonna be large.

827
00:35:27,740 --> 00:35:30,940
When we're in portrait mode
it's gonna kind of resize things

828
00:35:30,940 --> 00:35:32,970
one way and landscape another.

829
00:35:32,970 --> 00:35:34,930
So we always wanna write our code

830
00:35:34,930 --> 00:35:36,910
so it works in any size screen.

831
00:35:36,910 --> 00:35:39,670
But that's the approximate size of a point

832
00:35:39,670 --> 00:35:41,820
to give you an idea of a point.

833
00:35:41,820 --> 00:35:45,570
Now, one thing that's
kind of strange about this

834
00:35:45,570 --> 00:35:47,453
is this right here.

835
00:35:48,420 --> 00:35:53,030
It has put a label on
this piece of information

836
00:35:53,030 --> 00:35:55,077
that it needs to create a ZStack.

837
00:35:55,077 --> 00:35:56,700
And that didn't happen with Text.

838
00:35:56,700 --> 00:36:00,740
This doesn't say the string
or something like that.

839
00:36:00,740 --> 00:36:02,580
Text doesn't have one of these.

840
00:36:02,580 --> 00:36:05,120
But this is actually the norm.

841
00:36:05,120 --> 00:36:07,620
It's unusual to have something like Text

842
00:36:07,620 --> 00:36:10,770
where there's no label
here for an argument.

843
00:36:10,770 --> 00:36:12,390
You have to go out of your way to do that.

844
00:36:12,390 --> 00:36:14,090
And I'm gonna show you
how to go out of your way

845
00:36:14,090 --> 00:36:16,700
although we're not gonna
do that very often.

846
00:36:16,700 --> 00:36:19,430
Instead, when we create things,

847
00:36:19,430 --> 00:36:21,070
when we pass the information,

848
00:36:21,070 --> 00:36:23,960
we almost always label each piece.

849
00:36:23,960 --> 00:36:26,900
And this is true when we
call functions as well.

850
00:36:26,900 --> 00:36:28,880
所以，最有可能需要

851
00:36:28,880 --> 00:36:30,784
在 Swift 中习惯的事就是

852
00:36:30,784 --> 00:36:33,410
几乎所有函数中的每一个实参

853
00:36:33,410 --> 00:36:37,870
都需要实际参数标签

854
00:36:37,870 --> 00:36:40,500
这是从 Objective-C 继承而来的

855
00:36:40,500 --> 00:36:43,167
实际上这个东西非常好
因为如果没有这个（标签）

856
00:36:43,167 --> 00:36:46,530
就会变成 RoundedRectangle(10.0)

857
00:36:46,530 --> 00:36:48,730
（这个 10.0 的）意思是宽还是高？

858
00:36:48,730 --> 00:36:50,810
这个 10.0 的准确意思是什么？

859
00:36:50,810 --> 00:36:53,080
但是，只要我们把这个
cornerRadius 放在这儿

860
00:36:53,080 --> 00:36:54,597
一下子真相大白了：“噢，我在创建

861
00:36:54,597 --> 00:36:57,807
一个圆角半径是 10.0 的矩形”

862
00:36:59,070 --> 00:37:03,130
这儿看不太出来，矩形有没有圆角

863
00:37:03,130 --> 00:37:06,150
这是因为其实我选中了这一行代码

864
00:37:06,150 --> 00:37:08,890
所以在这周围有一条蓝线

865
00:37:08,890 --> 00:37:10,900
但是一旦我点到旁边来

866
00:37:10,900 --> 00:37:13,690
那么你就可以看到圆角矩形了

867
00:37:13,690 --> 00:37:15,720
如果放大点，你可以

868
00:37:15,720 --> 00:37:18,220
清晰地看到圆角矩形

869
00:37:18,220 --> 00:37:20,100
很明显，我们还需要做一些

870
00:37:20,100 --> 00:37:21,440
让它更显眼的处理

871
00:37:21,440 --> 00:37:24,280
我们不希望卡片撞到边上去

872
00:37:24,280 --> 00:37:26,430
而且它们也不应该是黑色的

873
00:37:26,430 --> 00:37:28,090
但是，首先要做点其他的

874
00:37:28,090 --> 00:37:30,690
这个我们将稍作讨论

875
00:37:30,690 --> 00:37:32,950
我想要做的下一件事是

876
00:37:32,950 --> 00:37:35,910
把 RounedRectangle 和 Text 结合在一起

877
00:37:35,910 --> 00:37:39,904
得记住，我们的卡片都得是 Text

878
00:37:39,904 --> 00:37:43,030
堆叠在 RoundedRectangle 上面

879
00:37:43,030 --> 00:37:46,670
我们可以通过返回 some View 来做到这一点

880
00:37:46,670 --> 00:37:51,460
因此，这里返回的视图叫做 ZStack

881
00:37:51,460 --> 00:37:54,294
ZStack 是一个结构体

882
00:37:54,294 --> 00:37:55,740
它表现得像一个 View

883
00:37:55,740 --> 00:37:59,281
就像 RoundedRectangle 是一个结构体

884
00:37:59,281 --> 00:38:00,850
行为表现得像视图一样

885
00:38:00,850 --> 00:38:01,800
Text 也一样

886
00:38:01,800 --> 00:38:03,803
事实上，ContentView 也是如此

887
00:38:04,882 --> 00:38:08,100
在这里创建 ZStack 时，需要一个实参

888
00:38:08,100 --> 00:38:12,910
用到的实参是 content，然后用大括号

889
00:38:12,910 --> 00:38:16,350
把这些 View 放到 List 里面

890
00:38:16,350 --> 00:38:19,653
很显然，我们不再需要这里的 return

891
00:38:20,690 --> 00:38:21,860
所以，列表就是这样了

892
00:38:21,860 --> 00:38:24,890
RoundedRectangle 在后，Text 在前

893
00:38:24,890 --> 00:38:26,960
这是列表里的第一个元素，这里面有两个

894
00:38:26,960 --> 00:38:29,480
当然也可以有五、六或七个

895
00:38:29,480 --> 00:38:32,320
我们把所有的元素排在一行，并将它们

896
00:38:32,320 --> 00:38:33,453
彼此堆叠

897
00:38:34,724 --> 00:38:36,380
ZStack 正是 some View

898
00:38:36,380 --> 00:38:38,670
实际上，这里的返回类型

899
00:38:38,670 --> 00:38:41,550
就是某种意义上的 ZStack

900
00:38:41,550 --> 00:38:44,370
而不是 Text 或 RoundedRectangle

901
00:38:44,370 --> 00:38:45,260
或其他东西

902
00:38:45,260 --> 00:38:48,310
但是 Swift 将自动识别出

903
00:38:48,310 --> 00:38:49,317
这里返回的是 ZStack

904
00:38:49,317 --> 00:38:51,403
因此它会替我们完成

905
00:38:52,430 --> 00:38:56,500
显然，这类组合器视图在

906
00:38:56,500 --> 00:38:58,210
构建复杂的视图时非常重要

907
00:38:58,210 --> 00:39:00,850
而且我们将在下周构建自己的组合器视图

908
00:39:00,850 --> 00:39:04,390
所以你真的需要理解它们是如何工作的

909
00:39:04,390 --> 00:39:06,030
我们正有条不紊地推进

910
00:39:06,030 --> 00:39:09,760
但是这里仍有些地方
（我们点这里的 Resume 恢复下）

911
00:39:09,760 --> 00:39:12,270
看起来和我们的卡片不太像

912
00:39:12,270 --> 00:39:14,650
首先，我们的卡片不是由黑色填满的

913
00:39:14,650 --> 00:39:18,830
它们应该有橙色的边框

914
00:39:18,830 --> 00:39:22,200
其次，我们很难看到卡片的边线

915
00:39:22,200 --> 00:39:24,370
因为它们离屏幕的边缘太近了

916
00:39:24,370 --> 00:39:25,460
那么让我们修复这两个问题

917
00:39:25,460 --> 00:39:29,700
首先，我们将描边绘制它而不是填满它

918
00:39:29,700 --> 00:39:31,200
然后我们实现它的方式是

919
00:39:31,200 --> 00:39:33,410
我们将调用

920
00:39:34,260 --> 00:39:37,020
RoundedRectangle 的 stroke 方法

921
00:39:37,020 --> 00:39:41,017
我们知道 RoundedRectangle
有和 View 一样的表现

922
00:39:41,017 --> 00:39:42,400
它也必须表现得像个 View 一样

923
00:39:42,400 --> 00:39:44,400
否则我们就不能把它传给 ZStack

924
00:39:44,400 --> 00:39:45,610
Text 也是一样的

925
00:39:45,610 --> 00:39:48,470
但是 RoundedRectangle 的行为

926
00:39:48,470 --> 00:39:50,350
还跟 Shape 一样

927
00:39:50,350 --> 00:39:54,410
其他的形状有 Circle、Capsule
贝塞尔曲线（Path）

928
00:39:54,410 --> 00:39:55,840
这些都是 Shape

929
00:39:55,840 --> 00:39:57,910
所有的形状都可以通过调用

930
00:39:57,910 --> 00:40:01,100
它们的 stroke 方法描边绘制出来

931
00:40:01,100 --> 00:40:03,150
你可以看到正是这样

932
00:40:03,150 --> 00:40:05,560
它沿着这个 RoundedRectangle

933
00:40:05,560 --> 00:40:08,720
描了一条边线

934
00:40:08,720 --> 00:40:10,830
stroke 方法的有趣之处在于

935
00:40:10,830 --> 00:40:13,030
它会返回一些东西

936
00:40:13,030 --> 00:40:15,050
猜猜它返回了什么？

937
00:40:15,050 --> 00:40:16,810
它返回了一个 View

938
00:40:16,810 --> 00:40:19,060
它返回了一个和 View 行为一致的东西

939
00:40:19,060 --> 00:40:24,060
这是必要的
因为这里一定要是一个 View

940
00:40:24,060 --> 00:40:27,000
否则我们就不能把它传给 ZStack

941
00:40:27,000 --> 00:40:30,230
因此这里就相当于一个

942
00:40:30,230 --> 00:40:32,560
描边后的 RoundedRectangle View

943
00:40:32,560 --> 00:40:35,000
现在我们有两个 View 在 ZStack 中

944
00:40:35,000 --> 00:40:37,173
一个是调用了 stroke 方法的 RoundedRectangle

945
00:40:37,173 --> 00:40:39,573
另一个是 Text

946
00:40:39,573 --> 00:40:44,573
这种调用 View 或 Shape 所属的方法

947
00:40:45,525 --> 00:40:46,650
来返回一个新的 View 的

948
00:40:46,650 --> 00:40:50,410
的形式将会非常普遍

949
00:40:50,410 --> 00:40:53,920
这是你第一次见到 Swift 方法的调用

950
00:40:53,920 --> 00:40:57,460
它非常简洁
仅需“.<方法名>”

951
00:40:57,460 --> 00:40:59,990
加上圆括号和实参

952
00:40:59,990 --> 00:41:02,490
其实 stroke 方法可以传入实参

953
00:41:02,490 --> 00:41:05,110
但即使不传入任何实参
它也能正常运转

954
00:41:05,110 --> 00:41:06,060
当没有实参传入时

955
00:41:06,060 --> 00:41:08,800
这个方法会遵从默认行为

956
00:41:08,800 --> 00:41:12,460
在 Shape 的边缘

957
00:41:12,460 --> 00:41:14,233
描出宽度为 1 点的线

958
00:41:15,256 --> 00:41:17,220
那么如何调整

959
00:41:17,220 --> 00:41:20,930
这条 RoundedRectangle 边框的颜色呢？

960
00:41:20,930 --> 00:41:23,340
它现在差不多是一种

961
00:41:23,340 --> 00:41:26,220
深灰的颜色

962
00:41:26,220 --> 00:41:28,160
如果我们想把它变成橙色

963
00:41:28,160 --> 00:41:29,460
应该怎么做呢？

964
00:41:29,460 --> 00:41:32,810
这里是一个 View

965
00:41:32,810 --> 00:41:36,440
对于所有 View
（所有与 View 行为一致的视图）来说

966
00:41:36,440 --> 00:41:39,747
你都可以调用名为 foregroundColor 的方法

967
00:41:41,920 --> 00:41:44,150
它需要一个 Color 类型的参数

968
00:41:44,150 --> 00:41:46,690
我会使用橙色（Color.orange）

969
00:41:46,690 --> 00:41:50,670
这会把用于绘制视图的颜色

970
00:41:50,670 --> 00:41:52,480
设置为橙色

971
00:41:52,480 --> 00:41:53,820
果不其然

972
00:41:53,820 --> 00:41:56,700
这里变成了橙色

973
00:41:56,700 --> 00:42:00,920
值得一提的是
我们可以在任一 View 中调用这个方法

974
00:42:00,920 --> 00:42:02,520
可以在这个 Text 上调用它

975
00:42:02,520 --> 00:42:03,970
可以看到，这样并不会报错

976
00:42:03,970 --> 00:42:05,869
当然，这里的 Text 没有发生任何变化

977
00:42:05,869 --> 00:42:07,130
是因为这是一个 emoji

978
00:42:07,130 --> 00:42:11,220
但如果这是一个字母“X”

979
00:42:11,220 --> 00:42:14,193
你会发现它变成了一个橙色的“X”

980
00:42:15,820 --> 00:42:17,790
这里不是调用这个方法的最佳地点

981
00:42:17,790 --> 00:42:22,790
我们还可以通过 ZStack 来调用这个方法

982
00:42:23,970 --> 00:42:26,860
那么告诉 View 把 foregroundColor

983
00:42:26,860 --> 00:42:29,950
设置为橙色是是个什么意思呢？

984
00:42:29,950 --> 00:42:30,960
ZStack 是一个 View

985
00:42:30,960 --> 00:42:33,600
它和 View 有一样的行为
所以它和所有其他 View 一样

986
00:42:33,600 --> 00:42:36,280
也有 foregroundColor 方法

987
00:42:36,280 --> 00:42:39,687
这样写的意义在于

988
00:42:39,687 --> 00:42:44,090
告诉所有它内部的 View
将 foregroundColor 设置为橙色

989
00:42:44,090 --> 00:42:46,733
这样也起了作用

990
00:42:46,733 --> 00:42:47,566
你看

991
00:42:47,566 --> 00:42:48,399
这里显示了橙色

992
00:42:48,399 --> 00:42:51,490
如果我们把这个 emoji 换成字母“X”

993
00:42:51,490 --> 00:42:54,610
“X”就也会是橙色

994
00:42:54,610 --> 00:42:57,100
这是因为 ZStack 设定了环境

995
00:42:57,100 --> 00:42:59,260
得以让其内部所有的 View

996
00:42:59,260 --> 00:43:01,710
都用这个方法绘制

997
00:43:01,710 --> 00:43:02,970
这个方法也可以被覆盖

998
00:43:02,970 --> 00:43:07,500
我们可以在这里写上 foregroundColor(Color.blue)

999
00:43:08,850 --> 00:43:12,360
我们就会得到一个蓝色的描边

1000
00:43:12,360 --> 00:43:15,593
但是这里（Text）仍然是橙色

1001
00:43:16,470 --> 00:43:19,380
因为我只把这个描边后的 RoundedRectangle View

1002
00:43:19,380 --> 00:43:23,580
的 foregroundColor 覆盖为蓝色

1003
00:43:23,580 --> 00:43:26,823
而并没有覆盖这个“X”的 foregroundColor

1004
00:43:27,790 --> 00:43:31,300
我们可以通过限定调用范围

1005
00:43:31,300 --> 00:43:33,750
来设定不同视图的颜色

1006
00:43:33,750 --> 00:43:35,373
这对于 ZStack 来说非常重要

1007
00:43:35,373 --> 00:43:37,830
因为我们将用这个 ZStack

1008
00:43:37,830 --> 00:43:40,080
来把卡片的前后

1009
00:43:40,080 --> 00:43:43,190
都统一设置为橙色

1010
00:43:43,190 --> 00:43:44,840
我们要把所有视图都设置成橙色

1011
00:43:44,840 --> 00:43:46,350
这样一次性设置整个 ZStack 的方式

1012
00:43:46,350 --> 00:43:48,517
非常便捷

1013
00:43:48,517 --> 00:43:51,060
我们通常会把这些

1014
00:43:51,060 --> 00:43:53,770
组合视图的修饰符独立成行

1015
00:43:53,770 --> 00:43:55,470
让它们能更加显眼

1016
00:43:55,470 --> 00:43:57,660
我们这里就留它们在同一行里吧

1017
00:43:57,660 --> 00:44:01,710
虽然也能将这些修饰符

1018
00:44:01,710 --> 00:44:04,240
另起一行

1019
00:44:04,240 --> 00:44:07,150
但我不打算这么做
随便你

1020
00:44:07,150 --> 00:44:08,960
取决于你的代码风格

1021
00:44:08,960 --> 00:44:11,070
你觉得怎样更易读、易理解

1022
00:44:11,070 --> 00:44:12,270
就怎么来

1023
00:44:13,600 --> 00:44:16,440
目前为止我们的卡片
看上去还不错

1024
00:44:16,440 --> 00:44:19,730
但有一点问题
卡片的边缘不是很明显

1025
00:44:19,730 --> 00:44:24,130
我们需要在边缘周围
填充一些空白

1026
00:44:24,130 --> 00:44:26,970
我们可以通过调用一个函数
为视图添加边缘填充

1027
00:44:26,970 --> 00:44:29,080
函数名为 padding

1028
00:44:29,080 --> 00:44:32,120
注意，当我在 Text 后面
添加 padding 函数后

1029
00:44:32,120 --> 00:44:35,040
Text 的周围瞬间
蹦出了一圈空白填充

1030
00:44:35,040 --> 00:44:36,730
当然，我也可以对 RoundedRectangle

1031
00:44:36,730 --> 00:44:40,960
做同样的事儿
因为它也是一个 View

1032
00:44:40,960 --> 00:44:43,920
输入 padding，效果不错

1033
00:44:43,920 --> 00:44:46,030
可以看到，周围多了一圈空白填充

1034
00:44:46,030 --> 00:44:48,770
甚至，我可以把空白填充在

1035
00:44:49,940 --> 00:44:52,917
整个 ZStack 的周围

1036
00:44:54,953 --> 00:44:56,120
这样应该就可以达到我想要的效果

1037
00:44:56,120 --> 00:44:57,260
在整个 ZStack 周围添加填充

1038
00:44:57,260 --> 00:44:58,970
而不用为每个
RoundedRectangle

1039
00:44:58,970 --> 00:45:01,470
单独添加边缘填充

1040
00:45:01,470 --> 00:45:02,880
比如我们之后会添加
RoundedRectangle

1041
00:45:02,880 --> 00:45:05,690
用来做卡片背面的
或者是一些其它类似的情况

1042
00:45:05,690 --> 00:45:07,980
能在外围调用这些函数
省了不少功夫

1043
00:45:07,980 --> 00:45:11,070
但需要注意的是
padding 与

1044
00:45:11,070 --> 00:45:12,570
foregourndColor 之间有些不同

1045
00:45:12,570 --> 00:45:15,120
padding 为 ZStack 添加边缘填充

1046
00:45:15,120 --> 00:45:17,400
使 ZStack 周围多了一圈空白

1047
00:45:17,400 --> 00:45:19,260
并且在 ZStack 中的视图都绘制

1048
00:45:19,260 --> 00:45:21,200
在这块填充后的区域里

1049
00:45:21,200 --> 00:45:23,490
而 foregroundColor
并不会直接对

1050
00:45:23,490 --> 00:45:25,197
ZStack 产生什么作用

1051
00:45:25,197 --> 00:45:26,950
ZStack 视图没有颜色相关的属性

1052
00:45:26,950 --> 00:45:28,690
它仅仅是包含了其它的 View 视图

1053
00:45:28,690 --> 00:45:31,560
但 foregroundColor 的值
会被传递到

1054
00:45:31,560 --> 00:45:33,943
ZStack 内 View 视图的环境中

1055
00:45:35,930 --> 00:45:36,870
好了，我们继续

1056
00:45:36,870 --> 00:45:38,770
我们已经看过预览的效果

1057
00:45:38,770 --> 00:45:41,770
接下来我们看一下在模拟器中

1058
00:45:41,770 --> 00:45:43,180
应用看起来如何

1059
00:45:43,180 --> 00:45:45,550
嗯，有点意思

1060
00:45:45,550 --> 00:45:49,097
应用正常运作了
但看上去不太好

1061
00:45:49,097 --> 00:45:52,240
这是因为我们的模拟器
现在是深色模式

1062
00:45:52,240 --> 00:45:55,190
但我们希望哪怕是在深色模式下

1063
00:45:55,190 --> 00:45:57,570
卡片的背景也是白色的

1064
00:45:57,570 --> 00:46:00,760
我们都不想看到黑色的卡片
堆在黑乎乎的背景前面

1065
00:46:00,760 --> 00:46:03,290
换句话说，我们希望卡片是白色的

1066
00:46:03,290 --> 00:46:04,910
那该怎么让它变成白色的呢？

1067
00:46:04,910 --> 00:46:08,090
很不幸，并没有一个函数能让你们在

1068
00:46:08,090 --> 00:46:11,030
用一种颜色给 RoundedRectangle
描绘轮廓的同时

1069
00:46:11,030 --> 00:46:13,350
再给它用另一个颜色填充

1070
00:46:13,350 --> 00:46:16,610
但没关系
我们现在是在一个 ZStack 中

1071
00:46:16,610 --> 00:46:19,760
所以我打算创建另一个
RoundedRectangle

1072
00:46:19,760 --> 00:46:23,730
这次我将调用 fill 而不是 stroke

1073
00:46:23,730 --> 00:46:26,700
记住，这个是放在另一个的后面

1074
00:46:26,700 --> 00:46:28,250
点 Resume 恢复预览

1075
00:46:28,250 --> 00:46:31,570
现在它被

1076
00:46:31,570 --> 00:46:35,140
这里环境设置的 foregroundColor
填满了，导致我看不到边线

1077
00:46:35,140 --> 00:46:38,310
还好 fill 可以传一个可选的参数

1078
00:46:38,310 --> 00:46:40,250
这个参数就是用来填充的颜色

1079
00:46:40,250 --> 00:46:43,810
而且这样会覆盖
这里的 foregroundColor

1080
00:46:43,810 --> 00:46:44,790
因此，现在它被白色填满了

1081
00:46:44,790 --> 00:46:48,390
如果我点击这里，它也填满了白色

1082
00:46:48,390 --> 00:46:52,213
这里是橙色的边框
有点难去看见它

1083
00:46:52,213 --> 00:46:56,230
它的宽度只有 1 点，而且还很靠近黑框

1084
00:46:56,230 --> 00:46:57,680
真的很难去看见它

1085
00:46:57,680 --> 00:46:59,574
让我们修复它

1086
00:46:59,574 --> 00:47:01,530
我说过可以传其他参数给 stroke

1087
00:47:01,530 --> 00:47:04,320
一个参数就是线宽

1088
00:47:04,320 --> 00:47:07,060
这里我们把它的线宽设定成 3

1089
00:47:07,060 --> 00:47:10,540
我们点 Resume 恢复下
看它运行在浅色模式中

1090
00:47:10,540 --> 00:47:11,373
这就是了

1091
00:47:11,373 --> 00:47:16,096
我们也可以通过运行应用
来看看深色模式中的效果

1092
00:47:16,096 --> 00:47:18,810
顺便提下，模拟器的深色模式和浅色模式

1093
00:47:18,810 --> 00:47:20,970
也可以在这里修改

1094
00:47:20,970 --> 00:47:22,800
你看这里的小按钮

1095
00:47:22,800 --> 00:47:24,200
你看这里的 Interface Style

1096
00:47:24,200 --> 00:47:27,580
你可以打开它，然后将深色模式
改成浅色模式

1097
00:47:27,580 --> 00:47:29,830
现在当你看到你的模拟器时

1098
00:47:29,830 --> 00:47:31,480
它已经是浅色模式了

1099
00:47:31,480 --> 00:47:35,373
这种切换的方式真的很酷

1100
00:47:37,890 --> 00:47:40,620
我们现在取得了很大的进步

1101
00:47:40,620 --> 00:47:43,590
我们的表情符号仍然很小

1102
00:47:43,590 --> 00:47:44,810
我将让它变得更大些

1103
00:47:44,810 --> 00:47:47,160
我能通过 Font 来实现

1104
00:47:47,160 --> 00:47:49,280
.font(Font.largeTitle)

1105
00:47:50,200 --> 00:47:53,563
Now I'm using a pre-canned
Font here called largeTitle.

1106
00:47:53,563 --> 00:47:56,998
There's some other ones called subheadline

1107
00:47:56,998 --> 00:47:58,900
and body and other things.

1108
00:47:58,900 --> 00:48:02,253
largeTitle happens to be
the largest one I can find.

1109
00:48:03,100 --> 00:48:04,830
If we resume, you are gonna see

1110
00:48:04,830 --> 00:48:06,210
it's gonna make our emoji larger.

1111
00:48:06,210 --> 00:48:08,810
Still not large enough.

1112
00:48:08,810 --> 00:48:11,460
Next week we're gonna
learn how to scale the Font

1113
00:48:11,460 --> 00:48:14,760
to an exact size that
fits nicely in our card.

1114
00:48:14,760 --> 00:48:17,580
But for now at least it's
getting a little bit larger.

1115
00:48:17,580 --> 00:48:18,940
One of the reason I did this

1116
00:48:18,940 --> 00:48:21,420
is I also wanna show you that this Font,

1117
00:48:21,420 --> 00:48:24,180
while it seems like this
would be a Text only thing,

1118
00:48:24,180 --> 00:48:27,400
it can actually be put on the ZStack

1119
00:48:27,400 --> 00:48:32,080
and it will set the font
environment for all Texts.

1120
00:48:32,080 --> 00:48:35,299
So if I had multiple
Texts inside the ZStack,

1121
00:48:35,299 --> 00:48:38,127
then it would use the Font,
that Font for all of them.

1122
00:48:38,127 --> 00:48:40,080
And you could easily
imagine building something

1123
00:48:40,080 --> 00:48:40,997
that had multiple pieces of Text

1124
00:48:40,997 --> 00:48:43,350
and you want them all to be the same Font.

1125
00:48:43,350 --> 00:48:47,240
And so setting it on the
ZStack is a really cool feature

1126
00:48:47,240 --> 00:48:48,203
for that as well.

1127
00:48:49,830 --> 00:48:53,500
So I've kind of got the card
somewhat looking like I want.

1128
00:48:53,500 --> 00:48:57,370
Now I want multiple cards
'cause I only have one card here

1129
00:48:57,370 --> 00:48:59,540
and I'd love to have multiple cards.

1130
00:48:59,540 --> 00:49:01,640
So how am I gonna get multiple cards?

1131
00:49:01,640 --> 00:49:06,090
I'm gonna do that by returning
a different kind of View,

1132
00:49:06,090 --> 00:49:07,393
another combiner View.

1133
00:49:07,393 --> 00:49:09,536
This is called a ForEach.

1134
00:49:09,536 --> 00:49:12,920
Now, a ForEach, of course
it takes arguments.

1135
00:49:12,920 --> 00:49:15,170
The first argument, it
takes two arguments.

1136
00:49:15,170 --> 00:49:20,170
The first argument is like an
iterable thing of some sort.

1137
00:49:20,370 --> 00:49:21,780
We'll talk about that in a second.

1138
00:49:21,780 --> 00:49:26,500
Then the second argument, just
like a ZStack, is content.

1139
00:49:26,500 --> 00:49:30,263
And that content is
going to be this ZStack.

1140
00:49:34,100 --> 00:49:36,050
What ForEach is gonna do

1141
00:49:36,050 --> 00:49:39,530
is it's going to iterate
over this iterable thing.

1142
00:49:39,530 --> 00:49:41,150
And for each of those things,

1143
00:49:41,150 --> 00:49:44,020
it's going to build one of these Views.

1144
00:49:44,020 --> 00:49:48,000
So it essentially is a way
to make multiple Views.

1145
00:49:48,000 --> 00:49:51,160
Kind of a View replicator
or a View iterator

1146
00:49:51,160 --> 00:49:53,160
if you wanna think of it like that.

1147
00:49:53,160 --> 00:49:56,980
So what is this iterable thing
we're talking about here?

1148
00:49:56,980 --> 00:49:59,650
Well, usually this is
going to be an array.

1149
00:49:59,650 --> 00:50:01,370
So you're gonna give it an array of things

1150
00:50:01,370 --> 00:50:03,320
and it's gonna, for each
of the things in the array,

1151
00:50:03,320 --> 00:50:05,030
it's going to create a View.

1152
00:50:05,030 --> 00:50:06,410
I'm not gonna use an array here.

1153
00:50:06,410 --> 00:50:08,800
We'll eventually switch to using an array

1154
00:50:08,800 --> 00:50:12,780
but I'm using another
iterable thing called a Range.

1155
00:50:12,780 --> 00:50:17,430
这是一个从 0 到 4
不包含 4 的半开半闭区间

1156
00:50:17,430 --> 00:50:20,570
也就是此处 Swift 语法的含义

1157
00:50:20,570 --> 00:50:25,570
表示一个从下限到上限的区间

1158
00:50:25,970 --> 00:50:27,340
不包含上限

1159
00:50:27,340 --> 00:50:31,230
如果你使用 ...
那就会包含上限

1160
00:50:31,230 --> 00:50:34,030
但是我不想包含上限

1161
00:50:34,030 --> 00:50:37,560
这样会逐个遍历 0，1，2，3

1162
00:50:37,560 --> 00:50:40,923
然后创建这里的 ZStack

1163
00:50:41,940 --> 00:50:43,660
这是一个重复器

1164
00:50:43,660 --> 00:50:45,180
现在，还有一件很酷的事

1165
00:50:45,180 --> 00:50:47,600
这里的 content 与之前一样

1166
00:50:47,600 --> 00:50:49,380
可以是一系列视图

1167
00:50:49,380 --> 00:50:53,060
我们 content 里只有一个 ZStack

1168
00:50:53,060 --> 00:50:54,910
但是我们可以有多个视图

1169
00:50:54,910 --> 00:50:56,960
就像在 ZStack 中一样
我们有多个视图

1170
00:50:56,960 --> 00:50:59,320
对于 ForEach，在大括号内

1171
00:50:59,320 --> 00:51:01,400
也可以有多个视图

1172
00:51:01,400 --> 00:51:03,970
另一个关于 ForEach
有点酷的地方是

1173
00:51:03,970 --> 00:51:06,200
我们将在之后讨论

1174
00:51:06,200 --> 00:51:11,060
关于这里 “in” 的含义

1175
00:51:11,060 --> 00:51:13,390
本质上这就是迭代变量

1176
00:51:13,390 --> 00:51:16,770
在这个情况下
这里的 index 初始值是 0

1177
00:51:16,770 --> 00:51:19,320
然后变为 1，接着是 2，最后是 3

1178
00:51:19,320 --> 00:51:21,900
共 4 个

1179
00:51:21,900 --> 00:51:23,330
现在，关于 ForEach

1180
00:51:23,330 --> 00:51:25,360
你会看到在预览中

1181
00:51:25,360 --> 00:51:29,580
实际上有 4 个单独的预览视图

1182
00:51:29,580 --> 00:51:33,360
那是因为 ForEach 不是布局视图

1183
00:51:33,360 --> 00:51:34,732
并不像 ZStack

1184
00:51:34,732 --> 00:51:37,540
ZStack 会将视图从后向前

1185
00:51:37,540 --> 00:51:39,960
堆叠着放在屏幕上

1186
00:51:39,960 --> 00:51:42,680
ForEach 并不会这样
如果你运行

1187
00:51:42,680 --> 00:51:43,930
如果我们在模拟器上运行

1188
00:51:43,930 --> 00:51:45,620
它可能会把视图放在不知什么地方

1189
00:51:45,620 --> 00:51:49,460
因为模拟器显然无法
模拟多个 iPhone

1190
00:51:49,460 --> 00:51:51,760
但是预览实际上更多是

1191
00:51:51,760 --> 00:51:54,410
显示发生了什么
即创建了 4 个这样的视图

1192
00:51:54,410 --> 00:51:56,500
所以预览向你展示了

1193
00:51:56,500 --> 00:51:57,820
所创建的 4 个视图

1194
00:51:57,820 --> 00:51:59,040
这样有利于调试

1195
00:51:59,040 --> 00:52:00,620
就像，“哦，是的，现在是这个”

1196
00:52:00,620 --> 00:52:02,410
这里 4 个视图完全一样

1197
00:52:02,410 --> 00:52:04,760
这对我们来说并不有趣

1198
00:52:04,760 --> 00:52:06,110
我们真正想做的是

1199
00:52:06,110 --> 00:52:08,647
同时将所有这 4 个视图显示在屏幕上

1200
00:52:08,647 --> 00:52:11,450
为此，我们需要另一个 stack

1201
00:52:11,450 --> 00:52:13,750
这里，我们不想把它们
从后往前堆叠在一起

1202
00:52:13,750 --> 00:52:16,130
这样我们就无法看到
后面的视图

1203
00:52:16,130 --> 00:52:17,470
因此我们想用不同的栈代替

1204
00:52:17,470 --> 00:52:19,503
我们在这里返回 HStack

1205
00:52:20,698 --> 00:52:23,683
HStack 像 ZStack 一样有
content 参数

1206
00:52:24,640 --> 00:52:26,960
你把需要排列的视图
放入 content 中

1207
00:52:26,960 --> 00:52:31,203
就像这样

1208
00:52:32,200 --> 00:52:36,840
HStack 不是将视图从后往前排列

1209
00:52:36,840 --> 00:52:38,820
而是在水平方向排列它们

1210
00:52:38,820 --> 00:52:40,670
这也是 H（水平的）的意思，从左到右

1211
00:52:40,670 --> 00:52:44,050
看这里，它从左到右排列它们

1212
00:52:44,050 --> 00:52:49,050
我说过 Swift 倾向略去

1213
00:52:49,120 --> 00:52:50,690
你不需要打字的部分

1214
00:52:50,690 --> 00:52:52,530
因此我仍可以删掉 return

1215
00:52:52,530 --> 00:52:53,990
因为不管信不信

1216
00:52:53,990 --> 00:52:56,993
这里仍然只有一个 View 将被返回

1217
00:52:57,910 --> 00:53:00,090
被用做这里的 body 的值

1218
00:53:00,090 --> 00:53:01,280
some View，这里它是一个 View

1219
00:53:01,280 --> 00:53:06,280
它是一个 HStack，它由生成 ZStack 的
ForEach 组成。HStack 有填充的间距

1220
00:53:07,060 --> 00:53:08,720
它有 foregroundColor 和 font

1221
00:53:08,720 --> 00:53:11,500
这就是被返回的一个 View

1222
00:53:11,500 --> 00:53:14,540
当然了，HStack 是一个组合器
它正在组合它们

1223
00:53:14,540 --> 00:53:17,950
ForEach 是一个组合器
ZStack 是一个组合器

1224
00:53:17,950 --> 00:53:20,820
但是他们都在 HStack 的内部

1225
00:53:20,820 --> 00:53:22,600
注意到当 HStack

1226
00:53:22,600 --> 00:53:25,710
遇到 ForEach 时
因为这里可以是一个列表

1227
00:53:25,710 --> 00:53:28,890
我们可以试下 Text("hello")

1228
00:53:28,890 --> 00:53:30,400
它把 hello 放到这里了

1229
00:53:30,400 --> 00:53:33,700
因此 ForEach 有点像列表

1230
00:53:33,700 --> 00:53:35,740
每一个 ZStack 都是独立的

1231
00:53:35,740 --> 00:53:36,870
这就是它展示成这样的原因

1232
00:53:36,870 --> 00:53:38,370
每个栈都是智能的

1233
00:53:38,370 --> 00:53:40,610
如果它内部有一个 ForEach

1234
00:53:40,610 --> 00:53:41,690
然后它会单独地编排

1235
00:53:41,690 --> 00:53:43,833
每一个 ForEach 中的内容

1236
00:53:45,050 --> 00:53:48,400
另一个值得注意的事是
这里的空隙

1237
00:53:48,400 --> 00:53:51,870
在这些视图间有一些空隙

1238
00:53:51,870 --> 00:53:53,850
它是这里的 padding 吗

1239
00:53:53,850 --> 00:53:55,910
不是的，这个 padding 是

1240
00:53:55,910 --> 00:53:57,957
HStack 外面的一圈
填充间距

1241
00:53:57,957 --> 00:54:02,520
因为是 HStack 调用的 padding 方法

1242
00:54:02,520 --> 00:54:06,670
那个空隙实际上是 HStack 实现的

1243
00:54:06,670 --> 00:54:08,800
并且它有一个参数可以设置
空隙的大小

1244
00:54:08,800 --> 00:54:10,970
在这里，我已经把 spacing
参数设为 0

1245
00:54:10,970 --> 00:54:15,410
或者把它设成 50
或者不设置它

1246
00:54:15,410 --> 00:54:17,630
很多时候我们都不设置它们

1247
00:54:17,630 --> 00:54:21,330
因为我们想这些空隙成为标准空隙

1248
00:54:21,330 --> 00:54:23,430
标准空隙在所有的应用中都是相同的

1249
00:54:23,430 --> 00:54:24,930
这里的 padding 也是一样的

1250
00:54:24,930 --> 00:54:26,940
我们没有设置它的参数
但是在 padding 方法中

1251
00:54:26,940 --> 00:54:30,170
你甚至可以设置上边的
边缘填充为 100

1252
00:54:30,170 --> 00:54:34,730
或者设置所有方向的边缘填充
都是 10

1253
00:54:34,730 --> 00:54:38,870
通常我们尽可能使用
标准的边缘填充

1254
00:54:38,870 --> 00:54:40,733
标准的边缘填充和空隙

1255
00:54:42,180 --> 00:54:46,900
我前面说过，还记得我们删掉了
这里的 return

1256
00:54:46,900 --> 00:54:49,430
这里还可以删掉一些

1257
00:54:49,430 --> 00:54:54,430
在 Swift 中，如果函数的
最后一个参数

1258
00:54:54,633 --> 00:54:57,310
或者构造器的最后一个参数
比如这里的 ForEach

1259
00:54:57,310 --> 00:54:58,450
它有两个参数

1260
00:54:58,450 --> 00:55:02,640
这里是它的第二个参数

1261
00:55:02,640 --> 00:55:06,320
如果第二个参数
是由大括号包含的

1262
00:55:06,320 --> 00:55:10,380
不管你信不信，你可以删掉这里的
标签（content:）

1263
00:55:10,380 --> 00:55:14,500
然后将实参放到函数调用的外面

1264
00:55:14,500 --> 00:55:15,720
这里同样是 ForEach

1265
00:55:15,720 --> 00:55:18,170
的构造器

1266
00:55:18,170 --> 00:55:19,550
这里是它的第二个参数

1267
00:55:19,550 --> 00:55:23,833
它现在在括号的外面了

1268
00:55:24,810 --> 00:55:27,420
这看起来有点疯狂

1269
00:55:27,420 --> 00:55:30,240
但是，先看看它会让我们的
代码变成什么样子

1270
00:55:30,240 --> 00:55:32,490
我将把这里都改掉

1271
00:55:32,490 --> 00:55:34,190
因为它仅有一个参数

1272
00:55:35,537 --> 00:55:37,954
我将它删掉

1273
00:55:39,190 --> 00:55:43,440
然后我在 HStack 上
进行同样的处理

1274
00:55:46,890 --> 00:55:48,570
这样看起来更简洁了

1275
00:55:48,570 --> 00:55:49,787
这些地方没有 content: 了

1276
00:55:49,787 --> 00:55:53,720
更进一步，如果没有参数

1277
00:55:53,720 --> 00:55:56,080
且这里有大括号在后面 

1278
00:55:56,080 --> 00:55:58,963
你也可以删除这里的小括号

1279
00:56:00,450 --> 00:56:04,300
这些可以很好地简化我们的代码

1280
00:56:04,300 --> 00:56:06,217
我们经常这样使用 ZStack

1281
00:56:06,217 --> 00:56:07,610
和 HStack

1282
00:56:07,610 --> 00:56:09,920
现在，如果我想设置 spacing 参数
我仍然可以

1283
00:56:09,920 --> 00:56:13,050
spacing: 0
完全没问题

1284
00:56:13,050 --> 00:56:15,130
它仍然是第一个参数

1285
00:56:15,130 --> 00:56:19,093
This is still the second
argument to the HStack there.

1286
00:56:20,508 --> 00:56:22,208
So it's kind of a little clean up.

1287
00:56:23,420 --> 00:56:25,960
So our code is looking
pretty clean already

1288
00:56:25,960 --> 00:56:27,700
making these four cards.

1289
00:56:27,700 --> 00:56:30,170
We can clean it up even a little more

1290
00:56:30,170 --> 00:56:32,330
by factoring out some of our code.

1291
00:56:32,330 --> 00:56:35,420
This ZStack here is essentially one card.

1292
00:56:35,420 --> 00:56:38,270
Wouldn't it be cool if I
just created a new struct

1293
00:56:38,270 --> 00:56:41,980
called a CardView which
also behaves like a View?

1294
00:56:41,980 --> 00:56:42,940
Which means what?

1295
00:56:42,940 --> 00:56:47,280
It has to have a var
body that is some View.

1296
00:56:47,280 --> 00:56:49,110
And in here we just return some View.

1297
00:56:49,110 --> 00:56:51,530
I'm gonna return a ZStack.

1298
00:56:51,530 --> 00:56:54,573
Cut that out of there, paste it in there.

1299
00:56:55,500 --> 00:56:56,900
And then in ContentView here,

1300
00:56:56,900 --> 00:56:58,613
I'm just gonna create a CardView.

1301
00:57:01,240 --> 00:57:03,760
So this is a way we can use the Views

1302
00:57:03,760 --> 00:57:06,830
to factor out our code
to do encapsulation.

1303
00:57:06,830 --> 00:57:09,710
To make our code look
even simpler and nicer.

1304
00:57:09,710 --> 00:57:10,863
Somebody looking at this ContentView,

1305
00:57:10,863 --> 00:57:15,190
it's really easy to see what
this is gonna look like.

1306
00:57:15,190 --> 00:57:17,610
And similarly down here.

1307
00:57:17,610 --> 00:57:18,693
Simple to see.

1308
00:57:19,920 --> 00:57:22,920
Now, the last thing I'm
gonna do here in this lecture

1309
00:57:22,920 --> 00:57:25,430
is do fronts and backs of cards.

1310
00:57:25,430 --> 00:57:29,090
'Cause right now, we only have
the front of the card shown.

1311
00:57:29,090 --> 00:57:30,930
We don't ever show the back of the card.

1312
00:57:30,930 --> 00:57:33,300
So how would we draw
this back of the card?

1313
00:57:33,300 --> 00:57:35,740
Well, it's just a ZStack as well

1314
00:57:35,740 --> 00:57:38,500
but it's filled with the foregroundColor.

1315
00:57:38,500 --> 00:57:40,950
So we could actually go ahead

1316
00:57:40,950 --> 00:57:43,240
and just copy and paste here

1317
00:57:43,240 --> 00:57:46,400
a RoundedRectangle to be the back.

1318
00:57:46,400 --> 00:57:48,267
And for the moment I'll comment this out.

1319
00:57:48,267 --> 00:57:50,480
And of course we don't
wanna fill with white.

1320
00:57:50,480 --> 00:57:54,930
We just wanna fill with whatever
our environment Color is.

1321
00:57:54,930 --> 00:57:56,720
Which it's going to get from here.

1322
00:57:56,720 --> 00:57:58,520
Notice that this foregroundColor

1323
00:57:58,520 --> 00:58:01,900
not only applies to
everything in the HStack

1324
00:58:01,900 --> 00:58:03,900
that ForEach passes it on down

1325
00:58:03,900 --> 00:58:05,450
so that it applies to the CardView

1326
00:58:05,450 --> 00:58:07,090
which passes it on down.

1327
00:58:07,090 --> 00:58:08,620
Which applies to the ZStack

1328
00:58:08,620 --> 00:58:10,120
which passes it on down

1329
00:58:10,120 --> 00:58:12,890
so that it applies to all these things.

1330
00:58:12,890 --> 00:58:14,710
So now if we resume.

1331
00:58:14,710 --> 00:58:17,143
We can see backs of cards.

1332
00:58:18,410 --> 00:58:20,720
See, here's the backs of our cards.

1333
00:58:20,720 --> 00:58:23,513
Right here, RoundedRectangles
that are just filled.

1334
00:58:24,450 --> 00:58:27,530
实际上，我们想根据条件来判断
这里是保留卡片正面的代码

1335
00:58:27,530 --> 00:58:31,200
还是保留卡片背面的代码

1336
00:58:31,200 --> 00:58:34,900
或者来判断卡片是正面朝上
还是背面朝上

1337
00:58:34,900 --> 00:58:37,910
因此，我们需要 if-then 语句

1338
00:58:37,910 --> 00:58:41,130
值得庆幸的是你可以把

1339
00:58:41,130 --> 00:58:44,760
一系列 View 连着 if 语句

1340
00:58:44,760 --> 00:58:47,540
都放到 ZStack 里

1341
00:58:47,540 --> 00:58:49,290
因此你可以先试下简单的
if 语句，比如

1342
00:58:49,290 --> 00:58:53,080
if isFaceUp

1343
00:58:53,080 --> 00:58:57,000
我们将把这三行代码移到
isFaceUp 的 if 语句中

1344
00:58:57,000 --> 00:59:00,000
然后，如果卡面是背面朝上的

1345
00:59:00,000 --> 00:59:02,933
我们将把这行代码放到这里

1346
00:59:03,970 --> 00:59:05,580
所以其实这里可以写
if 语句

1347
00:59:05,580 --> 00:59:07,550
现在这里有一些错误和警告
（译者注：这里没有警告）

1348
00:59:07,550 --> 00:59:10,206
因为我虚构了 isFaceUp

1349
00:59:10,206 --> 00:59:12,290
编译器还不知道它是什么

1350
00:59:12,290 --> 00:59:13,470
我只是虚构了它

1351
00:59:13,470 --> 00:59:15,970
那 isFaceUp 应该是什么呢？

1352
00:59:15,970 --> 00:59:18,750
我将它设为一个变量

1353
00:59:18,750 --> 00:59:21,563
它是一个普通的
内存变量

1354
00:59:21,563 --> 00:59:24,500
它不会有大括号

1355
00:59:24,500 --> 00:59:28,180
它只是一个普通的
内存变量

1356
00:59:28,180 --> 00:59:30,690
然后你看到这样做修复了
这下面所有的代码

1357
00:59:30,690 --> 00:59:34,460
CardView 是完美自洽的

1358
00:59:34,460 --> 00:59:38,630
它表达了，如果我的 isFaceUp
变量为真

1359
00:59:38,630 --> 00:59:40,880
然后这样，否则就这样

1360
00:59:40,880 --> 00:59:43,310
但是它在上面引起了一个错误

1361
00:59:43,310 --> 00:59:44,840
这个缺少 isFaceUp 参数的错误

1362
00:59:44,840 --> 00:59:47,210
到底是什么意思呢

1363
00:59:47,210 --> 00:59:48,790
为什么会出现它

1364
00:59:48,790 --> 00:59:50,360
其实我以前说过

1365
00:59:50,360 --> 00:59:53,650
在 Swift 中，所有的
变量都是强类型的

1366
00:59:53,650 --> 00:59:57,320
并且所有的变量必须有
初始值

1367
00:59:57,320 --> 00:59:59,170
因此我们可以为它
设置初始值

1368
00:59:59,170 --> 01:00:01,920
我们在这里写 = false

1369
01:00:01,920 --> 01:00:06,053
如我所说，这样做马上修复了
这个错误

1370
01:00:07,340 --> 01:00:08,840
这里展示的就是背面朝上
的卡片了

1371
01:00:08,840 --> 01:00:13,313
如果我把 isFaceUp 改成 true
然后点下 Resume

1372
01:00:15,530 --> 01:00:17,470
现在我们把卡片都翻到正面了

1373
01:00:17,470 --> 01:00:18,940
这是设置初始值的一种方式

1374
01:00:18,940 --> 01:00:21,400
如果可以的话
我们会经常用这种方式

1375
01:00:21,400 --> 01:00:23,150
但是如果我们不在这里设置它

1376
01:00:23,150 --> 01:00:24,650
没有给它设置默认值

1377
01:00:24,650 --> 01:00:26,630
这个错误又出现了

1378
01:00:26,630 --> 01:00:29,390
因为 Swift 正在告诉你

1379
01:00:29,390 --> 01:00:31,310
你尝试新建的 CardView

1380
01:00:31,310 --> 01:00:33,430
它有一个未初始化的变量

1381
01:00:33,430 --> 01:00:35,763
因此你必须初始化它

1382
01:00:36,620 --> 01:00:38,110
并且这里有个很酷的特性

1383
01:00:38,110 --> 01:00:41,820
如果你点下错误提示上的红色小按钮

1384
01:00:41,820 --> 01:00:44,590
很多时候你将看到小的 Fix 选项

1385
01:00:44,590 --> 01:00:46,950
And the Fix will fix the error for you.

1386
01:00:46,950 --> 01:00:49,000
Now, it's not always gonna fix it

1387
01:00:49,000 --> 01:00:51,990
exactly the way you want so
it doesn't work all the time.

1388
01:00:51,990 --> 01:00:54,310
And there's not always a Fix option.

1389
01:00:54,310 --> 01:00:55,460
'Cause sometimes it can't figure out

1390
01:00:55,460 --> 01:00:56,940
how to fix what you're saying.

1391
01:00:56,940 --> 01:00:58,040
But here it does work.

1392
01:00:58,040 --> 01:01:02,410
If I hit Fix, it actually adds an argument

1393
01:01:02,410 --> 01:01:03,780
to the creation of CardView

1394
01:01:04,630 --> 01:01:08,030
to set this variable isFaceUp.

1395
01:01:08,030 --> 01:01:09,863
So if I say false right here,

1396
01:01:10,990 --> 01:01:14,270
it's going to initialize this variable.

1397
01:01:14,270 --> 01:01:15,103
Let's resume.

1398
01:01:18,430 --> 01:01:19,830
And there it is.

1399
01:01:19,830 --> 01:01:21,700
False, face up is false.

1400
01:01:21,700 --> 01:01:22,890
This gets initialized false.

1401
01:01:22,890 --> 01:01:25,210
All these are not face up.

1402
01:01:25,210 --> 01:01:29,273
Now, hopefully this pattern
is looking familiar to you.

1403
01:01:29,273 --> 01:01:31,953
It's the same as this pattern.

1404
01:01:32,870 --> 01:01:34,860
Here I'm creating a ZStack.

1405
01:01:34,860 --> 01:01:36,740
It has some var probably.

1406
01:01:36,740 --> 01:01:38,430
Not necessarily because
there are other ways

1407
01:01:38,430 --> 01:01:39,810
to pass these variables.

1408
01:01:39,810 --> 01:01:42,130
But it might have a var
called cornerRadius.

1409
01:01:42,130 --> 01:01:46,140
And so it's forcing us to set it,

1410
01:01:46,140 --> 01:01:48,390
to define it 'cause we
can't have unset vars.

1411
01:01:49,460 --> 01:01:51,010
This is the same kind of thing.

1412
01:01:52,040 --> 01:01:55,950
Okay, that is it for this lecture.

1413
01:01:55,950 --> 01:01:57,080
In the next lecture,

1414
01:01:57,080 --> 01:01:59,210
I'm gonna actually start with some slides,

1415
01:01:59,210 --> 01:02:00,620
some conceptual stuff.

1416
01:02:00,620 --> 01:02:03,000
Then we'll get right back to this demo.

1417
01:02:03,000 --> 01:02:04,830
Normally I would tell
you a little bit more

1418
01:02:04,830 --> 01:02:07,220
about what's gonna happen
in the next lecture.

1419
01:02:07,220 --> 01:02:09,380
Except for that I'm releasing lecture two

1420
01:02:09,380 --> 01:02:10,910
along with lecture one.

1421
01:02:10,910 --> 01:02:12,690
So if you really want to
see what's in lecture two,

1422
01:02:12,690 --> 01:02:14,113
just go watch it right now.

1423
01:02:15,760 --> 01:02:18,993
>> [旁白] 请访问 stanford.edu
获取更多内容
